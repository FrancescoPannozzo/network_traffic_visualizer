% !TeX encoding = UTF-8
% !TeX program = pdflatex
% !TeX spellcheck = it_IT
\documentclass[binding=0.6cm]{sapthesis}
\usepackage{microtype}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{biblatex}
\usepackage{graphicx}
%\graphicspath{{immagini/}}
\addbibresource{bibliografia.bib}
%\lstset{basicstyle=\ttfamily, breaklines=true}
\usepackage{xcolor}  % Pacchetto per la gestione dei colori
\usepackage{caption}
\usepackage{amsmath}
\usepackage{amssymb}

\captionsetup{font=it}  % Imposta il font delle didascalie in corsivo


% Impostazioni di base per lstlisting
\lstset{
    basicstyle=\ttfamily,  % Usa un font monospace per il codice
    backgroundcolor=\color{gray!10},  % Sfondo leggermente grigio
    frame=single,  % Aggiunge un bordo attorno al codice
    %caption={didascalia},  % Didascalia del blocco di codice
    captionpos=b,  % Posizione della didascalia (b = bottom, t = top)
    escapeinside={(*@}{@*)},  % Permette di aggiungere LaTeX all'interno del codice se necessario
}
\renewcommand{\lstlistingname}{Codice}


\hypersetup{pdftitle={La mia tesi},pdfauthor={Francesco Biccari}}
\title{Generazione e visualizzazione grafica di traffico di reti}
\author{Francesco Pannozzo}
\IDnumber{699427}
\course{Laurea Triennale in Informatica}
\courseorganizer{Facoltà di Ingegneria dell'Informazione, Informatica e Statistica}
\AcademicYear{2023/2024}
\advisor{Prof. Daniele De Sensi}
\authoremail{francesco.pannozzo@libero.it}
\copyyear{2024}
\thesistype{Relazione di tirocinio}
\begin{document}
\frontmatter
\maketitle
\dedication{Dedicato alla\\ mia famiglia}
\begin{abstract}
Questa relazione descrive il lavoro di tirocinio interno svolto presso l'università La Sapienza, 
concretizzato nella realizzazione 
di un progetto volto a realizzare un software per poter visualizzare in forma grafica l'andamento 
del traffico di una rete.
Il progetto ha come obiettivo di mostrare il traffico di rete al variare del tempo e ciò viene raggiunto
tramite grafiche e animazioni generate programmaticamente. L'idea dell'ambito di tirocinio nasce 
dalla volontà di sperimentare una realizzazione front-end tramite la libreria Manim, un motore di animazioni per video
matematici esplicativi. Nel capitolo dedicato all'introduzione descriveremo l'ambito in cui si è tenuto il tirocinio, le motivazioni
alla base in cui è stato idealizzato l'argomento, seguito da un'analisi dello stato dell'arte attuale, descrivendo diverse realtà affini al progetto
e studiandone caratteristiche, i loro pregi e mancanze. A seguire ci sarà una descrizione dei contributi che vuole dare il progetto, scaturiti dall'analisi
dello stato dell'arte e infine una breve panoramica sulla base di partenza del progetto, descrivendo da cosa si è partiti, come è nata l'argomentazione
che ha portato alla scelta del progetto e la modalità di svolgimento. Nel capitolo 2 parleremo del contesto di sviluppo, ovvero le tecnologie impiegate.
Seguirà quindi una descrizione approfondita della scelta di certe tecnologie ma soprattutto del perchè le si è scelte. Il capitolo 3
descriverà il generatore di traffico e configurazione di rete, descrivendone funzionalità, condizioni inziali di setup di questa parte di applicazione e infine
descrivendo come il tutto viene generato, passando dalla distribuzione spaziale dei nodi e creazione dei links all'ottenimento dei files sui quali sono memorizzati i dati ottenuti.
Il capitolo 4 tratterà l'analizzatore di traffico, nello specifico dell'implementazione della logica che risiede dietro l'analisi del file contenente il traffico.
Il capitolo 5 sarà sul visualizzatore grafico, in cui verrà fornita una manoramica sulle logiche dietro la creazione degli elementi grafici e delle animazioni, le modalità
grafiche che è possibile ottenere, la descrizione delle scelte di design legate all'aspetto grafico e una sezione dedicata all'accessibilità, con cui si tratterà
l'implementazione di soluzioni che trattano il tema del daltonismo. Il capitolo 6 darà un quadro generale sulla complessità computazionle delle sezioni di codice più sensibili, analizzando gli andamenti asintotici di tutte le principali parti.
Infine avremo il capitolo 7, in cui tireremo le conclusioni del progetto, discutendo dei risulati finali e possibili impieghi futuri dell'applicazione.

\end{abstract}
\tableofcontents
\mainmatter
\chapter{Introduzione}
Nel mondo le reti informatiche sono oramai un concetto ben istanziato 
nella colletività, la loro presenza è soverchiante e si dirama nei più disparati settori.
Basti pensare già alle  reti PAN (Personal Area Network) le quali connettono dispositivi
personali entro pochi metri e che ognuno di noi usa abitualmente nella propria casa, 
alle reti LAN (Local Area Network), 
anch'esse presenti
nelle nostre case così come in uffici o edifici scolastici, le reti dei data center 
fino a giungere alla rete globale internet, la quale è creatrice a sua volta di paradigmi come
può essere l'internet of things. Le reti informatiche sono impiegate nei più vari 
settori come l'istruzione, in cui le reti
sono cruciali nelle scuole e nelle università per avere accesso a risorse educative o sfruttare l'e-learning, i servizi
pubblici governativi e sanitari, nel settore ludico e multimediale come il gioco online e l'attuale
streaming di contenuti multimediali: insomma, le reti informatiche sono di fatto una presenza piena e diffusissima
ed è estremamente difficile riuscire a immaginare il mondo come lo vediamo oggi senza questa tecnologia.
Con l'aumentare delle funzionalità legate alle reti, così come i dispositivi collegati a esse, capire cosa succede al
loro interno, come si muovono i dati, è quindi di cruciale importanza, tramite l'analisi dei dati che vi fruiscono è possibile fare diagnostica, per quanto
riguarda un discorso di monitoraggio, ma è anche possibile applicare le analisi in un ambito didattico e accademico.
Capire cosa sta succedendo in una rete in modo immediato e visivo è lo scopo di questo progetto, il quale punta a mostrare,
in modo grafico, l'andamento del traffico di una rete.
\section{Ambito del tirocinio}
Il progetto fa parte del percorso di tirocinio interno intrapreso presso l'Università La Sapienza di Roma. L'argomento su cui verte il progetto
è la realizzazione di un visualizzatore grafico dell'andamento del traffico di una rete di data center, basato
su animazioni programmatiche. Il tool permette di visualizzare gli switch rappresentanti 
i vari endpoints e i link
che li collegano i quali vengono colorati tramite animazioni nel tempo in base al traffico di 
rete precedentemente analizzato. Nel tool è presente anche una parte generativa di traffico di rete,
una creazione di traffico fittizia di vitale importanza ai fini di testing. Il progetto è suddiviso quindi in tre parti; una parte
che si occupa della generazione di una configurazione network e relativo traffico di rete, 
una parte che analizza il traffico di rete
calcolandone le medie percentuali di intervalli di tempo e aggiornate ripetutamente e infine 
una parte che visualizza il traffico analizzato
dall'analizzatore producendo una rappresentazione video.
\section{Motivazioni}
L'idea di sviluppare un visualizzatore grafico di traffico di rete è nata, 
in sede di proposta, dal Professore Daniele De Sensi, relatore del tirocinio, e dalla mia volontà di sviluppare un'applicazione avente il front-end
come focus dell'esperienza. Nel mio personale corso di studi presso il Dipartimento di Informatica non ho avuto modo
di studiare e approfondire un discorso legato al front-end, per cui la volontà di intraprendere questo percorso
nasce in primis da un forte interesse verso questo aspetto dell'informatica e in secondo luogo per un completamento di formazione professionale personale.
\section{Stato dell'arte}
\label{sec:stato_arte}
L'esigenza di analisi di reti informatiche ha portato alla luce svariati tool che permettono
appunto di analizzare cosa avviene in una rete, di studiarne i dati statistici e di visualizzare
graficamente determinati scenari. L'universita americana Johns Hopkins\cite{JohnsHopkinsUniversity2024} ha stilato una lista
di software per la visualizzazione e analisi di reti\cite{JHUDatavisNetwork2024}:




\begin{itemize}
  \item \textbf{Gephi\cite{Gephi2024}:}
  Gephi è il software leader di visualizzazione ed esplorazione per tutti i tipi di grafici e reti ed è open source. Le sue caratteristiche includono
  l'analisi esplorativa dei dati mediante manipolazioni di reti in tempo reale, 
  analisi dei collegamenti per rivelare le strutture sottostanti delle associazioni tra oggetti, 
  analisi dei social network per la creazione di connettori di dati sociali per mappare le organizzazioni della comunità e le reti di piccoli mondi, 
  analisi della rete biologica per rappresentazione di modelli di dati biologici ed esportazione e 
  creazione poster per promuovere e divulgare il lavoro scientifico con mappe stampabili di alta qualità.
  \item \textbf{Cytoscape\cite{Cytoscape2024}:} è una piattaforma software open source per visualizzare 
  reti complesse e integrarle con qualsiasi tipo di dati. Consiste in una piattaforma per
  visualizzare reti di interazioni molecolari e percorsi biologici, potendo integrare queste reti con annotazioni,
  profili di espressione genica e altri dati. Originariamente progettato per la ricerca biologica, 
  ora è una piattaforma generale per l'analisi e la visualizzazione di reti complesse.
  \item \textbf{GraphVis\cite{Graphviz2024}:} è un software di visualizzazione di grafici open source. Caratteristiche,
  I programmi di layout Graphviz accettano descrizioni di grafici in un semplice linguaggio di testo e creano diagrammi in formati utili, 
  come immagini e SVG per pagine web; PDF o Postscript per l'inclusione in altri documenti; 
  o visualizzare in un browser grafico interattivo. Graphviz ha molte funzionalità utili 
  per diagrammi concreti, come opzioni per colori, caratteri, layout di nodi tabulari, stili di linea, 
  collegamenti ipertestuali e forme personalizzate.
  \item \textbf{igraph\cite{igraph2024}:} è una collezione di librerie per creare, manipolare grafici e analizzare ponendo l'enfasi nell'efficienza,
  portabilità e facilità d'uso. Igraph è open source e gratuito e può essere programmato in R, Python, Mathematica e C/C++
  \item \textbf{UCINET6\cite{UCINET2024}:} è un pacchetto software per l'analisi dei dati dei social network. UCINET viene fornito con il tool di visualizzazione di rete NetDraw.
  Può leggere e scrivere una moltitudine di file di testo diversamente formattati, nonché file Excel. 
  I metodi di analisi dei social network includono misure di centralità, identificazione di sottogruppi, analisi di ruolo, teoria dei grafi elementari e analisi statistica basata sulla permutazione. 
  Inoltre, il pacchetto dispone di potenti routine di analisi delle matrici, come l'algebra delle matrici e la statistica multivariata.
  \item \textbf{SocNetV\cite{SocNetV2024}:}è un'applicazione software gratuita multipiattaforma per l'analisi e la visualizzazione dei social network.
  Tra le caratteristiche principali troviamo il poter disegnare i social network, caricare i campi da un file supportato
  (GraphML, GraphViz, Adjacency, EdgeList, GML, Pajek, UCINET, ecc.), personalizzare attori e collegamenti tramite sistema punta e clicca,
  analizzare le proprietà dei grafici e dei social network, produrre report HTML e incorporare layout di visualizzazione di rete
  \item \textbf{Pajek\cite{Pajek2024}:}  è un software per la visualizzazione e l'analisi delle reti. La sua forza risiede nel poter analizzare reti complesse potendo arrivare
  fino a un miliardo di vertici. L'analisi e la visualizzazione vengono eseguite utilizzando sei tipi di dati: 
  rete (grafico), partizione, vettore, cluster (sottoinsieme di vertici), permutazione (riordinamento dei vertici, proprietà ordinali); e gerarchia (struttura generale ad albero sui vertici).
\end{itemize}

\section{Contributi}
Da un punto di vista grafico e quindi di visualizzazione, la maggior parte degli strumenti sopra elencati, permette una certa forma di personalizzazione nella disposizione dei nodi, sia automaticamente attraverso algoritmi di layout sia manualmente, 
permettendo agli utenti di spostare i nodi per ottimizzare la visualizzazione o per enfatizzare certi aspetti della rete. Tuttavia, la possibilità di
avere animazioni dinamiche che mostrino l'andamento del traffico nel tempo, mostrando la variazione del colore in base alla quantità dello stesso, risulta
essere una caratteristica meno comune nei software di analisi di rete, nello specifico:
\begin{itemize}	
  \item Gephi: Non supporta nativamente animazioni dinamiche basate su traffico in tempo reale. Tuttavia, la sua flessibilità e la capacità di aggiungere plugin potrebbero permettere implementazioni personalizzate.
  \item Cytoscape: Anche se fortemente orientato all'analisi statica, plugin o estensioni potrebbero aggiungere capacità simili.
  \item GraphVis (Graphviz): Principalmente orientato verso la visualizzazione statica; non supporta direttamente animazioni dinamiche dei link basate sul traffico.
  \item igraph: Come libreria di analisi, non è orientato verso la visualizzazione in tempo reale o animazioni dei link basate su traffico nel suo utilizzo standard.
  \item UCINET (con NetDraw): Focalizzato sull'analisi statica di reti sociali; non supporta animazioni dinamiche in base al traffico.
  \item SocNetV: Orientato all'analisi statica e alla visualizzazione; non è progettato per visualizzare animazioni dinamiche basate sul traffico.
  \item Pajek: Simile agli altri, è più un tool per l'analisi statica e la visualizzazione di grandi reti, senza un supporto diretto per animazioni dei link basate su traffico.
\end{itemize}
In questo contesto, l'inserimento di una caratteristica che permetta di fare quanto premesso come base
del progetto di tirocinio, risulta particolarmente indicata nel contribuire a fornire una soluzione visiva come
strumento aggiuntivo di analisi di una rete, di debugging e anche come strumento didattico. La possibilità di
avere un riscontro visivo istantaneo di cosa avviene nel tempo in una rete, a livello di traffico, può dare immediato feedback nel
caso ci fosse un problema di congestione in un punto nevralgico, oppure mostrare parti di rete libere dove poter studiare un
reindirizzamento dello stesso, volto a ottimizzare le prestazioni. A livello didattico ciò si potrebbe mostrare per presentazioni così come per didattica tramite banalmente spiegazioni. 
Insomma i benefici derivanti da una rappresentazione del generale sono evidenti e ciò
può essere di grosso aiuto nell'analisi così anche solo come semplice rappresentazione del traffico di rete, nonchè uno strumento complementare a quanto già presente in circolazione.

\section{Base di partenza del progetto}
Il progetto è partito da zero, si basa sullo sviluppo totalmente nuovo dell'applicazione ed è stato tutto idealizzato e pianificato in sede di proposta.
Come approfondirò in seguito, nella sezione dedicata alla tecnologia impiegata, il progetto non è l'unica cosa a essere partita da zero, poichè il linguaggio
scelto per sviluppare l'applicazione è Python\cite{PythonWebsite}, linguaggio non incluso nel mio 
personale percorso di studi e che ho dovuto necessariamente studiare da zero per poter affrontare il percorso di tirocinio.
Il lavoro è stato svolto individualmente.

\chapter{Contesto di sviluppo: le tecnologie impiegate}
Il progetto, a livello di tecnologia impiegata, pone le fondamenta su tre aspetti che andremo a 
elencare di seguito, descrivendo le varie motivazioni che hanno spinto a sceglierli. 
\section{Python}
Uno dei primi aspetti di cui si è tenuto conto è stata
la scelta del linguaggio di programmazione che, come accennato precedentemente, è Python. Ci sono diversi validi motivi per cui 
puntare su questa tecnologia;
in primis è materia di insegnamento alla facoltà di Informatica de La Sapienza, ciò ha quindi una forte valenza accedemica, 
in secondo luogo risulta essere il linguaggio più
usato al mondo, ad affermarlo è l' Institute of Electrical and Electronics Engineers (IEEE)\cite{IEEEwebsite}\cite{IEEESpectrumArticle2023} 
un'associazione internazionale di scienziati professionisti con l'obiettivo della promozione delle scienze tecnologiche. Il linguaggio ha molte caratteristiche ottime, come
una sintassi semplice e leggibile che lo rende facile da imparare e semplice da usare per gli sviluppatori esperti accorciando di gran lunga i tempi di sviluppo,
una grande versatilità per poter essere usato in ambiti diversi come l'intelligenza artificiale, il web development, data analysys e molto altro, un ampio
supporto delle librerie, due delle quali usate proprio nel progetto (di cui ne parlerò a breve), una grande comunità in cui trovare facilmente risorse, tutorial e supporto,
una interoperabilità che permette un'ottima integrazione con altre tecnologie e altri linguaggi, orientato agli oggetti volto a facilitare la gestione del codice e migliora il riuso,
scalabile e di facile integrazizone. 

\section{La libreria Manim}
Il secondo aspetto risiede nella scelta della libreria Manim\cite{Manim}, che viene definita come "Animation engine for explanatory math videos". Lo scopo di Manim è quindi
quello di animare concetti tecnici legati alla matematica e si affida alla semplicità di Python per generare animazioni in modo programmatico. Manim può produrre anche immagini e gif, ma è nella produzione di video che splende, in questo modo
è possibile progettare animazioni e renderle visibili in movimento, coprendo figure algebriche, grafici cartesiani, grafi e molto altro\cite{Manim}. 
La libreria offre molta liberà sui risultati che si vogliono ottenere, può renderizzare singole immagini, gif e da molte opzioni per quanto riguarda l'output video, fornendo la possibilità
di renderizzarli nei formati più comuni con la possibilità di personalizzazione del framerate:
\begin{itemize}	
    \item 480p (SD): 854 x 480
    \item 720p (HD): 1280 x 720
    \item 1080p (HD): 1920 x 1080
    \item 1440p (2K): 2560 x 1440
    \item 2160p (4K): 3840 x 2160
\end{itemize}
Manim viene impiegato principalmente per presentazioni che implichino aspetti matematici, la sfida del progetto è stata quella di 
cercare di sfruttare le potenzialità della libreria e renderle al servizio di uno strumento di analisi sul traffico di reti, una sfida vinta come potremo vedere in seguito.
Il terzo aspetto tecnologico riguarda l'aspetto di gestione dei dati. Un visualizzatore grafico di traffico di reti ha bisogno principalmente di due insiemi di informazioni importanti; uno riguarda tutte le informazioni
che riguardano il come è costruita la rate, parliamo quindi degli endpoint quali sono gli switch e conseguenti informazioni annesse, pensiamo ad esempio all'indirizzo di rete, un nome identificativo e così via, ma parliamo anche dei link che collegano
i vari endpoints, con la necessità di tenere traccia delle loro capacità trasmissive, la tipologia di rete, se ha una struttura a grafo completo, mesh, torus o disposizione libera e molte altre informazioni che discuteremo in seguito.

\section{I formati Json e Yaml}
L'altro insieme di informazioni deriva dal traffico vero e proprio, rendendo quindi necessario un sistema di mantenimento dei dati legati ai pacchetti trasmessi. L'analisi di questi due insiemi di informazioni ha portato alla valutazione di tre sistemi per la strutturazione di dati; json\cite{RFC791}, yaml\cite{RFC9512} e csv\cite{RFC4180}.
Dopo attenta anlisi si è deciso di adottare il formato json per strutturare e memorizzare i dati legati al traffico, con la possibilità di scegliere anche il formato yaml, mentre per i dati relativi alla descrizione della rete il compito è stato affidato esclusivamente a yaml, csv è stato scartato.
Perchè csv è stato scartato? Sebbene csv rappresenti una valida alternativa tenendo conto di aspetti prestazionali, essendo un formato molto veloce da analizzare, da leggere e scrivere, tuttavia lo diventa meno quando c'è bisogno di strutturare maggiormente i dati con strutture più complesse della semplice forma tabellare, tipicamente usate nei database. 
L'idea di scartarla, sia per strutturare i dati della rete che per quelli del traffico, deriva principalmente dai seguenti motivi:

\begin{itemize}
    \item \textbf{Leggibilità:} uno dei primi intenti del progetto era di rendere l'applicazione il più leggibile possibile, questo perchè si è
    fortemente voluto attribuirne anche scopi di debugging e didattici, laddove avere una certa leggibilità è più che ragionevole.
    \item \textbf{Strutture complesse:} sicuramente il motivo più importante. Con csv non è possibile rappresentare strutture complesse, parliamo ad esempio di oggetti
    all'interno di altri oggetti. Sebbene per come sia ora strutturato il progetto una rappresentazione cvs è ancora possibile, ciò potrebbe non esserlo in futuro
    nell'ottica di espansione del progetto
\end{itemize}
Per esplicare meglio il concetto di struttura complessa non fattibile è possibile focalizzarsi
 sul seguente esempio. Segue la rappresentazione di un pacchetto di rete così come viene
 utilizzato nel progetto, in questo caso una lista contenente un solo elemento:

 {\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={pacchetto di rete rappresentato in json}, label={fig:packet_example}]
[    
    {
        "A": 1,
        "B": 2,
        "t": "2024-03-22 12:30:00",
        "d": 1518
    }
]
\end{lstlisting}
 }

Dove A e B sono gli endpoints interessati, t è il timestamp di creazione pacchetto e d 
la dimesione del payload in bytes(). In csv questa struttura è rappresentabile come segue:

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={pacchetti di rete rappresentati in csv}]
    A,B,t,d
    2,1,2024-03-22 12:30:00,1518
    2,1,2024-03-22 12:30:00,1518
\end{lstlisting}
}

Tuttavia se si dovesse rendere questa struttura più complessa, avremmo problemi a realizzarla in csv, basterebbe l'aggiunta
di un campo che a sua volta necessita di informazione strutturata, come ad esempio 
inserire le informazione dell'header:
{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={pacchetto di rete maggiormente strutturate in json}]
    [
        {
          "A": 1,
          "B": 2,
          "t": "2024-03-22 12:30:00",
          "d": 4000,
          "ip_header": {
            "version": 4,
            "ihl": 5,
            "type_of_service": 0,
            "total_length": 300,
            "identification": 98765,
            "flags": {
              "reserved_bit": false,
              "dont_fragment": true,
              "more_fragments": false
            },
            "fragment_offset": 0,
            "time_to_live": 64,
            "protocol": 6,
            "header_checksum": "2B5A",
            "source_address": "192.168.1.1",
            "destination_address": "192.168.1.2"
          }
        }
      ]
\end{lstlisting}
}
In questa struttura abbiamo ben due oggetti nidificati, ip header e flags. 
Questo tipo di struttura è difficilmente replicabile in csv che si presta maggiormente
per strutture piatte mentre json e yaml permettono molta più libertà di strutturazione.
La scelta del formato json per rappresentare i dati del traffico di rete è quindi legata alla possibilità di espandere la
rappresentazione con strutture più complesse in ottica di espansioni future del progetto, ma è indubbiamente legata alle prestazioni che questo formato riesce a dare.
Json è un formato ampiamente supportato e la sua semplicità permette di ottenere risultati ottimi per le operazioni di parsing, lettura e scrittura per strutture aventi grandi quantità di dati.
Sebbene l'applicazione supporti sia json che yaml per quanto riguarda il memorizzare i dati legati al traffico, la scelta preferenziale ricade su json.
Questo perchè, nonostante json produca files di dimensioni maggiori rispetto a yaml, la schiacciante velocità di elaborazione di json rende la creazione di
un file di dimensioni maggiore ampiamente giustificabile, considerando soprattuto la natura del progetto in cui non vi è una
criticità d'uso nella dimensione dei files. Come vedremo in seguito, i test eseguiti sui tempi di lettura e scrittura rispettivamente della stessa struttura
ricreata sia in json che in yaml, sapranno ben
dimostrare quanto appena affermato. Per impiegare questi formati sono state usate rispettivamente la libreria json \cite{PythonJSONLibrary}, appartenente alla libreria standard di Python, e la
libreria esterna PyYAML \cite{PyYAMLDocumentation}, un parser ed emitter di yaml per Python.
Infinie giungiamo ai motivi per cui si è scelto invece esclusivamente yaml per rappresentare i 
dati relativi alle informazioni che descrivono la rete. Le motivazioni consistono sempre nella volontà
di garantire un formato che si presti a espansioni future e quindi che possano richiedere strutturazioni complesse, ma soprattutto,
in questo caso specifico, nell'alta leggiblità che yaml offre. Generalmente i dati che servono a descrivere una rete non sono mai paragonabili a quelli
necessari per registrare tutto il traffico, si voleva dare quindi uno strumento molto chiaro da leggere per fare in modo che la configurazione di rete
fosse sempre molto chiara, intuitiva e di facile accesso, sia in scrittura che in lettura. 
Per dare una stima di grandezza, il file
di configurazione network che produce il generatore di pacchetti, basato su 50 switch collegati come un grafo mesh pesa appena 9 KB.
Seguirà la descrizione approfondita del progetto, principalmente suddiviso in tre parti; la prima 
parte riguarda la generazione di traffico di rete fittizio, la seconda è l'analizzatore dei dati di configurazione di rete e relativo traffico mentre la terza
parte riguarda il visualizzatore grafico vero e proprio.

\chapter{Generatore di traffico e configurazione di rete}

Il progetto è composto da tre anime, una di esse è un generatore di traffico di rete e relativa configurazione.
Lo scopo del generatore è da ricercare principalmente in motivazioni di testing, ma può essere
 usato anche in ambito didattico per scopi
esemplicativi. Con esso è stato possibile testare l'analizzatore e conseguentemente il visualizzatore grafico, nonchè si è creato 
uno strumento esemplicativo di determinati funzionamenti collegati al traffico di rete.
La configurazione di rete consiste nella produzione di una struttura dati che descriva 
le caratteristiche della rete, la quale
verrà memorizzata in un file dal nome "network" e avente estensione yaml, mentre per quanto
riguarda il traffico, crea una struttura che consiste in una lista di pacchetti e memorizzata in un file denominato "packets".

\section{Funzionalità e setup} 
Lo script permette di eseguire quanto descritto mettendo a
 disposizione due modalità, auto e user. Entrambe le modalità produrranno due files, 
 network.yaml conterà le caratteristiche della rete e il file packets.json (o packets.yaml
 a seconda della scelta) conterrà il traffico vero e proprio di tutti i pacchetti generati 
 dalla simulazione. La modalità auto chiede all'utente il numero di switch, la capacità dei
  link e la tipologia del grafo con il quale rappresentare la rete (completo, mesh, torus) e
   imposterà in modo del tutto automatico
   la disposizione degli switch in base alla scelta del grafo effettuata. Per poter operare,
    in entrambe le modalità, lo script ha bisogno di leggere il file sim\_setup.yaml, il quale contiene le informazioni necessarie per la configurazione. 
    Il file di setup è impostato come segue:
{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={esempio di setup file}, label={codice:sim_setup_example}]
    averageDelta: 1000
    updateDelta: 100
    creationDelta: 100
    startSimTime: 2024-03-22 12:30:00
    simTime: 5
    packetSize: 4000
    colorblind: "no"
    dotsSize: "fixed"
    trafficVariation: random
    packetsFile: json
\end{lstlisting}
}
Andremo ora a spiegare il significato dietro ogni voce:
\begin{itemize}
    \item \textbf{averageDelta:} rappresenta l'intervallo temporale in millisecondi 
    delle medie percentuali di traffico da calcolare nell'analizzatore di traffico.
    \item \textbf{updateDelta:} rappresenta ogni quanti millisecondi debbano essere aggiornate le medie averageDelta nell'analizzatore
    \item \textbf{creationDelta:} rappresenta ogni quanti millisecondi debbano essere creati i pacchetti nel generatore
    \item \textbf{startSimTime:} è il datetime dell'inizio della generazione nel formato \newline
    YY:MM:DD HH:MM:SS, inoltre è possibile specificare anche un eventuale tempo avente millisecondi da specificare come ad esempio 
    12:30:00.500
    \item \textbf{simTime:} è la durata della simulazione in secondi
    \item \textbf{packetSize:} è la dimensione in bytes di un pacchetto, i pacchetti nella simulazione avranno questa dimensione
    \item \textbf{colorblind:} è una stringa "yes" o "no" che abilita, se posta su "yes", una visualizazione compatibile per persone daltoniche
    di cui parleremo successivamente quando discuteremo della parte relativa al visualizzatore grafico.
    \item \textbf{trafficVariation:} è la variazione di traffico per secondo che si desidera impostare; 
    può essere il valore "random" oppure uno dei seguenti [5, 10, 20, 25, 50] e 
    di conseguenza determinerà la variazione percentuale di traffico che avviene 
    ogni secondo di simulazione. Il valore "random" sceglie casualmente una percentuale 
    ogni secondo con un valore che va da 0 a 100
    \item \textbf{packetsFile:} specifica quale tecnologia si vuole utilizzare per il file packets, 
    si può scegliere tra json e yaml
\end{itemize}

La generazione di pacchetti è calcolata sulla base 
della capacità dei link fornita e su un valore casuale di percentuale di traffico 
che varia ogni secondo, per esempio avendo 6 links su 3 secondi di simulazione e il 
parametro "trafficVariation" settato a random potremmo avere delle assegnazioni di 
percentuali di traffico come le seguenti:
{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={esempio di variazione traffico casuale}]
    endpoints: [1, 2], sim second: 0, trafficPerc: 65
    endpoints: [1, 3], sim second: 0, trafficPerc: 9
    endpoints: [2, 4], sim second: 0, trafficPerc: 23
    endpoints: [2, 5], sim second: 0, trafficPerc: 67
    endpoints: [3, 6], sim second: 0, trafficPerc: 7
    endpoints: [3, 7], sim second: 0, trafficPerc: 87
    endpoints: [1, 2], sim second: 1, trafficPerc: 86
    endpoints: [1, 3], sim second: 1, trafficPerc: 26
    endpoints: [2, 4], sim second: 1, trafficPerc: 13
    endpoints: [2, 5], sim second: 1, trafficPerc: 13
    endpoints: [3, 6], sim second: 1, trafficPerc: 39
    endpoints: [3, 7], sim second: 1, trafficPerc: 65
    endpoints: [1, 2], sim second: 2, trafficPerc: 31
    endpoints: [1, 3], sim second: 2, trafficPerc: 54
    endpoints: [2, 4], sim second: 2, trafficPerc: 11
    endpoints: [2, 5], sim second: 2, trafficPerc: 20
    endpoints: [3, 6], sim second: 2, trafficPerc: 17
    endpoints: [3, 7], sim second: 2, trafficPerc: 46
\end{lstlisting}
}
Una volta lanciato il generatore avremo le seguenti possibilità di scelte:

\begin{itemize}
    \item \textbf{auto:} la modalità automatica, provvederà a disporre i nodi (switch) di rete in modo del
    tutto automatico. Dopo aver scelto la modalità auto si dovranno inserire i seguenti parametri via prompt:
    \begin{itemize}
        \item numero di switch
        \item capacità dei link
        \item tipologia della rappresentazione grafica della rete (grafo completo, mesh, torus)
    \end{itemize}
    \item \textbf{user:} una modalità in cui l'utente può personalizzare la configurazione di 
    rete
\end{itemize}
La modalità user necessita di un file "custom\_graph.yaml" con i parametri 
necessari a descrivere la rete del quale si vuole analizzare il traffico. 
Con questa modalità l'utente ha completa libertà nel personalizzare la rete ed 
è tenuto quindi a descriverne ogni suo aspetto. Il custom\_graph.yaml prevede la 
struttura di un dizionario in cui a ogni chiave corrisponde un valore, mostriamo un esempio con possibili varianti che elencheremo:

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={esempio di custom file per la configurazione}, label={fig:custom_graph_example}]
    ---
    data:
      graphType: mesh
      coordinates:
        - [1, 0, 2, 0]
        - [3, 0, 4, 5]
        - [6, 7, 8, 9]
      switches:
        1:
          ip: "123.123.123.0"
          switchName: Anthem
        2:
          ip: "123.123.123.1"
          switchName: Beta
        3:
          ip: "123.123.123.2"
          switchName: Cyber
        4:
          ip: "123.123.123.3"
          switchName: Dafne
        5:
          ip: "123.123.123.4"
          switchName: Eclipse
        6:
          ip: "123.123.123.5"
          switchName: Fox
        7:
          ip: "123.123.123.6"
          switchName: Gea
        8:
          ip: "123.123.123.7"
          switchName: H20
        9:
          ip: "123.123.123.8"
          switchName: Italy
      links:
        - { linkCap: 10,  endpoints: [1, 3] }
        - { linkCap: 100, endpoints: [1, 6] }
        - { linkCap: 10,  endpoints: [3, 6] }
        - { linkCap: 10,  endpoints: [4, 8] }
        - { linkCap: 10,  endpoints: [5, 9] }
        - { linkCap: 100, endpoints: [3, 5] }
        - { linkCap: 10,  endpoints: [6, 9] }
        - { linkCap: 100, endpoints: [4, 5] }
        - { linkCap: 10,  endpoints: [6, 7] }
        - { linkCap: 10,  endpoints: [7, 8] }
        - { linkCap: 100, endpoints: [8, 9] }
        - { linkCap: 10,  endpoints: [2, 4] }
        - { linkCap: 10,  endpoints: [2, 8] }
      phases:
        2024-01-01 00:00:01: "phase1"
        2024-01-01 00:00:02: "phase2"
\end{lstlisting}
}

Descriviamo i vari parametri:
\begin{itemize}
    \item \textbf{graphType:} identifica la tipologia del grafo da rappresentare, sono disponibili tre opzioni:
    \begin{itemize}
        \item \textbf{mesh:} l'algoritmo individua in modo automatico gli archi (i link) che collegano i nodi (gli switch) adiacenti tra loro presenti nella matrice coordinates
        \item \textbf{torus:} esegue lo stessa procedura usate per mesh e in addizione collega tra loro i nodi che si trovano alle estremità della matrice
        \item \textbf{graph:} è la modalità più libera, collega gli switch tramite i link forniti dall'utente, indipendentemente da dove vengano collocati
    \end{itemize}
    \item \textbf{coordinates:} rappresenta le coordinate dei vari switch, i quali vanno rappresentati con un id numerico che va da 1 a 1000. C'è una precisa motivazione di design per questa scelta ed è legata a una rappresentazione grafica ottimale del visualizzatore grafico. Gli zeri invece rappresentano uno spazio vuoto in cui non è presente uno switch.
    \item \textbf{links:} rappresenta i link della rete i quali possono essere specificati con i campi:
    \begin{itemize}
        \item \textbf{linkCap:} esprime la capacità del link in Mbps
        \item \textbf{endpoints:} esprime gli endpoints collegati al link
    \end{itemize}
    \item \textbf{phases:} rappresenta le fasi temporali che accompagnano la durata dell'attività di rete, sono identificate tramite timestamp che ha come valore la descrizione della fase che parte dal timestamp stesso.
\end{itemize}
Il lettore avrà notato che per il campo graphType manca la possibilità di scegliere un grafo completo. In realtà la possibilità c'è e risiede semplicemente
nell'opzione "graph", essendo la modalità libera, l'utente può tranquillamente descrivere un grafo completo in questo modo avendo chiaramente l'accortezza di posizionare i nodi in modo tale che i link si sovrappongano.
Tuttavia ciò e solo valido per quanto riguarda il generatore, se l'utente dovesse fornire un file network.yaml, che descriva un grafo completo,
da fornire direttamente come input per l'analizzatore di traffico, può farlo tranquillamente, in quel caso avrà ben due modi per farlo:
scegliere il graphType come "complete" per avere una disposizione circolare dei nodi e lasciando il campo "coordinates" vuoto, oppure come "graph" ma
specificando le coordinate. Torneremo sull'argomento nel capitolo dedicato al visualizzatore grafico.
Come si può notare dalla figura \ref{fig:custom_graph_example}, gli switch sono identificati tramite un valore numerico, 
questa è una precisa scelta di design e mira a mantenere il concetto di leggibilità sempre
presente. In questo caso la scelta deriva dal semplificare e rendere immediatamente chiaro il campo coordinates 
(rappresentato da una matrice quadrata), così che l'occhio possa identificare immediatamente la rappresentazione della disposizione. Questa leggibilità è ottenuta
grazie al formato yaml, il quale minimizza i caratteri da scrivere.
Così facendo si rende intuitivo il posizionamento degli switch nello spazio, inoltre è una caratteristica importante per quanto riguarda il
visualizzatore grafico, poichè rappresentando i nodi con un valore numerico che va da 1 a 1000 (spiegheremo il perchè di questa scelta a breve), è 
possibile rappresentare su schermo una grande quantità di elementi per far si che possano essere visualizzati contemporaneamente e rimanere leggibili ma soprattuto,
 distinguibili. Uno dei problemi maggiormente riscontrati nelle applicazioni discusse nella sezione Stato dell'arte \ref{sec:stato_arte} è che, le varie soluzioni impiegate
 per la rappresentazione dei nodi, risultano essere confusionarie per via di una sovrapposizione massiva di link che collegano i nodi, mentre uno degli scopi del
 progetto è di rendere altamente leggibile l'interpretazione del traffico di rete ed è per questo che si è posto una particolare attenzione in termini di
 sovrapposizione degli elementi, spaziatura adeguata, scelta dei colori giusti e altri aspetti che approfondiremo nella sezione apposita riguardante la parte
 di visualizzazione grafica.
Qualora la capacità dei link sia uguale per tutti è possibile insererire il campo 
linkCap per poter così evitare di avere lo stesso valore nei vari link rappresentati nel campo links, potendo rappresentare solo gli endpoints:

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={esempio di custom file con capacità uguali a tutti i link}, label={fig:custom_graph_example}]
data:
  graphType: torus
  coordinates:
    - [1, 0, 2, 0]
    - [3, 0, 4, 5]
    - [6, 7, 8, 9]
  linkCap: 10
  switches:
    1:
      ip: "123.123.123.0"
      switchName: A
    2:
      ip: "123.123.123.1"
      switchName: B
    3:
      ip: "123.123.123.2"
      switchName: C
    4:
      ip: "123.123.123.3"
      switchName: D
    5:
      ip: "123.123.123.4"
      switchName: E
    6:
      ip: "123.123.123.5"
      switchName: F
    7:
      ip: "123.123.123.6"
      switchName: G
    8:
      ip: "123.123.123.7"
      switchName: H
    9:
      ip: "123.123.123.8"
      switchName: I
  links:
    - [1, 3]
    - [1, 6]
    - [3, 6]
    - [4, 8]
    - [5, 9]
    - [3, 5]
    - [6, 9]
    - [4, 5]
    - [6, 7]
    - [7, 8]
    - [8, 9]
    - [2, 4]
    - [2, 8]
  phases:
    2024-01-01 00:00:01: "phase1"
    2024-01-01 00:00:02: "phase2"
\end{lstlisting}
}

Un'altra possibilità è quella di lasciare che il programma ricavi in automatico i link, 
in questo caso basterà specificare solo linkCap che sarà uguale per tutti i link:

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={esempio di custom graph file con link di eguale capacità}]
    ---
data:
  graphType: mesh
  coordinates:
    - [1, 2, 3]
    - [4, 5, 6]
    - [7, 8, 9]
  linkCap: 10
  switches:
    1:
      ip: "123.123.123.0"
      switchName: Anthem
    2:
      ip: "123.123.123.1"
      switchName: Beta
    3:
      ip: "123.123.123.2"
      switchName: Cyber
    4:
      ip: "123.123.123.3"
      switchName: Dafne
    5:
      ip: "123.123.123.4"
      switchName: Eclipse
    6:
      ip: "123.123.123.5"
      switchName: Fox
    7:
      ip: "123.123.123.6"
      switchName: Gea
    8:
      ip: "123.123.123.7"
      switchName: H20
    9:
      ip: "123.123.123.8"
      switchName: Italy
  phases:
    2024-01-01 00:00:01: "phase1"
    2024-01-01 00:00:02: "phase2"
\end{lstlisting}
}

Come si può notare, questo tipo di approccio concede una certa libertà di azione, dando la possibilità
di prestarsi anche a soluzioni ibride di grafi canonici. Possiamo avere un esempio di quanto descritto
nell'opzione torus. Il tipo di grafo torus generalmente è associato ad un grafo in cui ogni nodo
ha quattro nodi adiacenti come mostrato in figura:

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{immagini/torus_graph.png}
    \caption{esempio di torus graph \cite{torusgraph}}
    \label{fig:torus_graph}
\end{figure}

Tuttavia, le opzioni messe a disposizione dall'applicazione permettono una certa libertà di movimento,
per esempio avendo una configurazione come quella riportata in figura \ref{fig:custom_graph_example},
una volta analizzati i dati tramite l'analizzatore e forniti come imput al visualizzatore, potremmo ottenere
un risultato in cui i nodi nella matrice che abbiano un valore pari a zero, non vengano
collegati:
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/only_links.JPG}
    \caption{risultato grafico del visualizzatore per un custom graph file}
    \label{fig:hybrid_custom_torus}
\end{figure}

L'ultima possibilità di personalizzazione consiste nel poter personalizzare la matrice coordinates come si preferisce, seguendo sempre la regola
che laddove c'è un valore numerico, esso sarà un nodo, mentre laddove ci sarà uno zero verrà inteso come spazio vuoto. Quindi se si vuole rappresentare
un grafico che non sia di tipo mesh o torus, bisogna specificare nel campo graphType il valore "graph", mostriamo un esempio:

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={esempio di custom graph file, graphType posto al valore graph}]
    ---
    data:
      graphType: graph
      coordinates:
        - [0, 0, 0, 0, 1, 0, 0, 0, 0]
        - [0, 0, 2, 0, 0, 0, 3, 0, 0]
        - [0, 4, 0, 5, 0, 6, 0, 7, 0]
      linkCap: 10
      switches:
        1:
          ip: "123.123.123.0"
          switchName: A
        2:
          ip: "123.123.123.1"
          switchName: B
        3:
          ip: "123.123.123.2"
          switchName: C
        4:
          ip: "123.123.123.3"
          switchName: D
        5:
          ip: "123.123.123.4"
          switchName: E
        6:
          ip: "123.123.123.5"
          switchName: F
        7:
          ip: "123.123.123.6"
          switchName: G
      links:
        - [1, 2]
        - [1, 3]
        - [2, 4]
        - [2, 5]
        - [3, 6]
        - [3, 7]
      phases:
        2024-01-01 00:00:01: "phase1"
        2024-01-01 00:00:02: "phase2"
\end{lstlisting}
}

Come possiamo intuire osservando i valori nel campo coordinates, l'esempio ricrea la struttura di un albero, i links sono appunto specificati 
nel campo link e una volta generato il traffico con il generatore, analizzato e dato come input 
al visualizzatore otteniamo un risultato come in figura \ref{fig:tree_custom}.
\newline
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/free_graph.JPG}
    \caption{risultato grafico del visualizzatore per un custom graph file in modalità "graph"}
    \label{fig:tree_custom}
\end{figure}
Vien da sè che si ottiene così una certa libertà di espressione bidimensionale, con la quale l'utente può scegliere
la rappresentazione che più si addice alla rete che si vuole realizzare.

\section{Esecuzione del generatore}
\label{sec:esecuzione_del_generatore}
Il generatore può essere pensato come suddiviso in sezioni logiche per quanto riguarda la stesura del codice nello script; la prima riguarda la fase
di interazione con l'utente, il codice  strutturato in una serie di richieste per l'utente e controlli sul corretto inserimento dei dati, successivamente
vi è la parte di caricamento del file contentente i parametri di rete \ref{codice:sim_setup_example}, segue la creazione dei links, la generazione del traffico
creando tutti i pacchetti, si creano le informazioni inerenti agli switch e il tutto viene memorizzato sui files. Vedremo più in dettaglio questi
aspetti, a livello di codice, nel capitolo dedicato allo studio della complessità computazionale e prestazioni, mentre in questo capitolo ci focalizzeremo
sulla descrizione su come viene generato il tutto.
Descriveremo ora il funzionamento dell'esecuzione vera e propria dello script relativo alla generazione del traffico e dei files che produrrà.
All'avvio l'utente sarà chiamato a scegliere tra due modalità, come accennato precedentemente, auto e user; scegliendo auto verrà chiesto all'utente
di scegliere il numero di switch che si vuole attribuire alla rete, da un minimo di due a un massimo di mille. Questo intervallo numerico nasce per
poter rappresentare una rete in un generico data center, il quale generalmente ospita fino a un migliaio di switch. Ciò non toglie che,
in un ottica futura di espansione del software, questo range non possa essere espanso con le dovute modifiche. Successivamente alla scelta nel numero
di switch l'utente sarà chiamato a scegliere la tipologia di rete potendo scegliere tra i valori "c" (completo), "m" (mesh) e "t" (torus). Per 
grafo completo
si intende quando un nodo è collegato a tutti i nodi rimanenti, è il grafo computazionalmente parlando più oneroso da ricreare per via 
della grande crescita
del numero di archi da rappresentare al crescere dei nodi. Avendo infatti \(n\) nodi avremo un numero di link \(l\) pari a:
\begin{equation}
    l = \frac{n(n-1)}{2}
    \label{eq:link_number}
\end{equation}
Ogni nodo è collegato a tutti gli altri meno se stesso, \(n(n-1)\), e si divide per due perchè gli archi non vanno contati due volte. Si parla quindi di una crescita esponenziale al variare del numero di nodi.
Per grafo mesh si è inteso una rappresentazione in cui ogni nodo ha quattro nodi adiacenti, fatta eccezione di coloro che risiedono alle estremità, come
raffigurato nell'esempio in figura creato dal visualizzatore \ref{fig:mesh_example}.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/mesh_example.jpg}
    \caption{risultato grafico del visualizzatore per un auto mesh graph}
    \label{fig:mesh_example}
\end{figure}
Nel caso della scelta di un grafico torus, il visualizzatore provvederà a disegnare la struttura come mostrata in figura \ref{fig:torus_graph}.
La scelta successiva in cui l'utente sarà invitato a fornire, riguarda la capacità che si vuole associare ai link appartenenti alla rete, potendo
scegliere tra i valori 10, 100 e 1000 e vengono intese come grandezze espresse in megabytes (MB).
Una volta inseriti questi parametri il generatore provvederà a creare la configurazione di rete e il rispettivo traffico, memorizzando i dati rispettivamente
nei files network.yaml e packets.json/yaml.
Scegliendo la modalità user non viene richiesto alcun dato via prompt, questo perchè, come descritto in precedenza, tutti i dati di cui ha bisogno
il generatore devono essere presenti nel file custom\_graph.yaml \ref{fig:custom_graph_example}. Un diagramma che illustra le fasi e le
 scelte cui è possibile fare
è rappresentato in figura \ref{fig:diagramma_generatore}.   
\begin{figure}[h]
    \centering
    \includegraphics[width=0.40\textwidth]{immagini/diagramma_selezioni_config_gen.jpg}
    \caption{diagramma di flusso di esecuzione del generatore}
    \label{fig:diagramma_generatore}
\end{figure}


Il generatore si serve di una serie di funzioni di utilità per creare le strutture in base alle scelte dell'utente. 
Tutte le tipologie di rappresentazioni avvengono seguendo una logica di distribuzione dei nodi in forma matriciale, fatta eccezione della tipologia di
grafo completo (spiegheremo nella parte dedicata al visualizzatore il perchè), come descritto in dettaglio nel prossimo paragrafo.


\section{Creazione dei links e nodi}
Dopo aver effettuato le scelte via prompt e dopo che il programma ha caricato i parametri dal file sim\_setup.yaml 
avviene la creazione dei link e dei nodi. Per i link viene creata una struttura che consiste in un dizionario in cui ogni chiave sarà associata
ai parametri del link con un identificativo come chiave:

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[language=Python, caption={esempio di rappresentazione di un link}, label={codice:links_key_value}]
    {
        "endpoints": sorted((switch_a, switch_b)),
        "capacity": link_cap,
        "trafficPerc": 0
    }
\end{lstlisting}
}
Il campo enpoints rappresenta i nodi che il link collega, capacity è la capcità del link e trafficPerc è la percentuale di traffico del link.
Le percentuali di traffico del link sono pensate per variare ogni secondo di generazione e servono solo ai fini della creazione della quantità di traffico, questo specifico campo non sarà riportato nel network.yaml
pochè è un dato che non servirà più, di fatti la struttura che rappresenta i link verrà memorizzata come una lista di dizionari come segue:


{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={esempio di struttura finale dei links}, label={codice:links_structure}]
  - capacity: 10
    endpoints:
    - 1
    - 2
  - capacity: 10
    endpoints:
    - 2
    - 3
  - capacity: 10
    endpoints:
    - 1
    - 4
  - capacity: 10
    endpoints:
    - 4
    - 5
\end{lstlisting}
}

Il campo \(capacity\) identifica la capacità del link espressa in MB, mentre \(endpoints\) è una lista di due identificatori numerici compresi tra
2 e 1000 che rappresentano i nodi che li collega.
Ci sono diverse configuazioni che lo script sarà tenuto a considerare in base alle scelte dell'utente, possiamo individuarle in:

\begin{itemize}
    \item \textbf{Modalità auto:} ci sono 3 configurazioni possibili, complete graph, mesh e torus.
    \begin{itemize}
        \item \textbf{Complete graph:} i links vengono in modo tale che ogni nodo sia collegato a tutti i nodi rimanenti. Non c'è un riferimento esplicito al posizionamento poichè, come vedremo successivamente, sarà compito del visualizzatore grafico disporre i nodi nello spazio.
        \item \textbf{Mesh graph: } i links vengono creati in modo tale che ogni nodo abbia 4 nodi adiacenti rispetto a una distribuzione spaziale su matrice rettangolare, a eccezione dei nodi che risiedono alle estremità.
        \item \textbf{Torus graph: } i links vengono creati in modo da replicare il più possibile la struttura di un torus graph completo, come mostrato in fig. \ref{fig:torus_graph} utilizzando lo stesso sistema di disposizione usato per il mesh graph basato su matrice rettandolare.
        Qualora il numero di nodi scelto non riesca a riempire la matrice, l'algoritmo non creerà i link di nodi che non risultino essere alle estremità.
    \end{itemize} 
    \item \textbf{Modalità user:} i links vengono semplicemente caricati dal file e copiati nella struttura. Nel caso in cui i link non siano specificati nel custom file allora vengono generati.
\end{itemize}
In questa fase i nodi (ovvero gli endpoints) sono definiti tramite il campo \(enpoints\) dei vari links, solo successivamente verrà aggiunto l'indirizzo di ciascun endpoint, un suo nome e l'ID.
Nel caso di modalità auto vengono creati indirizzi automaticamente a partire da \(10.0.0.1\), l'identificativo è un valore numerico crescente a partire da 1 e il nome è semplicemente la composizione
della parola \(switch\) seguita dall' ID, come ad esempio \(switch1\).
Nel caso di modalità user tutte le informazioni inerenti agli switch saranno copiate nella struttura così come sono memorizzate nel file custom\_graph.yaml

\section{Distribuzione dei nodi: aspect ratio}
\label{sec:aspect_ratio}
Come accennato precedentemente, la distribuzione dei nodi è pensata per essere disegnata in forma matriciale, questo segue una precisa scelta di design e riguarda
l'aspect ratio adotatto per disegnare al meglio gli elementi su schermo tramite la libreria Manim, la quale produce video in 16:9, quindi è sorta l'esigenza
di sfruttare al massimo questo formato visivo per poter inserire nel modo più coerente e ottimizzato possibile i vari elementi della rete.
La soluzione adottata è stata quella di pensare al numero di nodi come un'area di un quadrato (matrice quadrata) e successivamente trovare l'area equivalente 
di un rettangolo (matrice rettangolare) considerando un
aspetc ratio di 16:9. Consideriamo il numero di nodi \(A\) come l'area del quadrato e con \(n\) un suo lato \(n = \sqrt{A}\).
Denotiamo con $l$ la lunghezza e con $h$ l'altezza del rettangolo. La condizione di proporzione si può esprimere come
\[
\frac{l}{h} = \frac{16}{9}.
\]
Dato che l'area del rettangolo deve essere uguale a quella del quadrato, abbiamo che
\[
l \cdot h = n^2.
\]
Utilizzando la proporzione, possiamo esprimere $l$ in termini di $h$ come
\[
l = \frac{16}{9}h.
\]
Sostituendo questa espressione nell'equazione dell'area, otteniamo
\[
\frac{16}{9}h \cdot h = n^2,
\]
che si semplifica in
\[
\frac{16}{9}h^2 = n^2.
\]
Da qui, isoliamo $h$ ottenendo
\[
h^2 = \frac{9}{16}n^2 \quad \Longrightarrow \quad h = n \cdot \frac{3}{4}.
\]
Risostituendo il valore di $h$ nell'espressione di $l$, abbiamo
\[
l = \frac{16}{9} \cdot n \cdot \frac{3}{4} = n \cdot \frac{4}{3}.
\]
Abbiamo ottenuto la base \(l\), corrispondente al numero di colonne della matrice, e l'altezza \(h\), corrispondente al numero
di righe, del rettangolo in 16:9. Tuttavia c'è l'esigenza di rappresentare numeri interi poichè la radice dell'area \(A\) può non essere un numero intero e di conseguenza anche \(l\) e \(h\).
Per ovviare al problema si è deciso di arrotondare \(l\) e \(h\) all'intero superiore, così facendo, qualora si avesse
il lato \(s\) avente parte decimale, sarà sempre verificato:
\begin{equation}
    (l+1)(h+1)>lh
\end{equation}
riuscendo a contenere l'area e rimanendo in proporzione.

\section{Generazione del traffico}
Successivamente alla creazione dei link e dei nodi vi è la generazione del traffico, ovvero la creazione di tutti i pacchetti che vengono
creati. Descriveremo ora il criterio di creazione del traffico; l'idea è quella di iterare su frazioni di tempo cui l'unità temporale è definita
 dal campo creationDelta (tutti i campi che citeremo provengono dal file setup sim\_setup.yaml). L'algoritmo cicla per ogni frazione di 
 tempo per la durata della generazione, definita nel campo
 simTime e per ciascuna calcola un quantitativo di pacchetti, proporzionale alla 
percentuale di traffico, per ogni link presente nella rete. Ogni secondo trascorso viene cambiata la percentuale di traffico di ogni link secondo
la scelta fatta nel campo trafficVariation. Nei grafici nelle figure \ref{fig:generatore_traffico_random}, \ref{fig:generatore_traffico_fissato} possiamo vedere due esempi di andamento di variazione di traffico percentuale.
Il tempo, data e ora, che definisce quando è cominciata la trasmissione lo ritroviamo nel timestamp startSimTime.
Poichè per ogni frazione il calcolo dei pacchetti può non essere preciso, ovvero può capitare che ci sia un numero con una parte decimale, l'algoritmo
provvede a recupere questa rimanenza, tramutarla in pacchetto e aggiungerla. Questo fa si di avere un'elevata approssimazione, tendente al 100\% per
quanto riguarda l'essere più fedeli possibili alle percentuali di traffico da generare.

\begin{figure}[ht]
    \centering
    \begin{minipage}{0.48\textwidth}
      \includegraphics[width=\linewidth]{immagini/generatore_traffico_random.png}
      \caption{esempio, varaizione di traffico percentuale casuale per 10 secondi}
      \label{fig:generatore_traffico_random}
    \end{minipage}\hfill
    \begin{minipage}{0.48\textwidth}
      \includegraphics[width=\linewidth]{immagini/generatore_traffico_fissato.png}
      \caption{esempio, varaizione di traffico percentuale fissato per 10 secondi}
      \label{fig:generatore_traffico_fissato}
    \end{minipage}
\end{figure}

\section{Files prodotti}
\label{sec:files_prodotti}
Una volta creati links e nodi, generato il traffico, costruito le strutture del traffico e della rete, lo script provvederà a salvare il risultato nei files descritti precedentemente.
Un esempio di file network lo ritroviamo in figura \ref*{codice:network_file_example}.
{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={esempio di network file}, label={codice:network_file_example}]
- - capacity: 10
    endpoints:
    - 1
    - 2
  - capacity: 10
    endpoints:
    - 1
    - 3
  - capacity: 10
    endpoints:
    - 3
    - 4
  - capacity: 10
    endpoints:
    - 2
    - 4
- - address: 10.0.0.1
    switchID: 1
    switchName: switch1
  - address: 10.0.0.2
    switchID: 2
    switchName: switch2
  - address: 10.0.0.3
    switchID: 3
    switchName: switch3
  - address: 10.0.0.4
    switchID: 4
    switchName: switch4
- averageDelta: 1000
  colorblind: 'no'
  dotsSize: fixed
  graphType: mesh
  linkCap: 10
  packetsFile: json
  simTime: 5
  startSimTime: 2024-03-22 12:30:00
  updateDelta: 100
- coordinates:
  - - 1
    - 2
  - - 3
    - 4
- 2024-03-22 12:30:01: phase1

\end{lstlisting}
}
Il file è una lista contenente tutti i valori relativi alla configurazione network, avendo i seguenti campi nell'ordine:

\begin{itemize}
    \item Una lista di links ognuno dei quali descrive la capacità e gli endpoints al quale è collegato
    \item Una lista di switch ognuno dei quali descrive l'indirizzo, il proprio identificativo e un eventuale nome associato
    \item Un oggetto rappresentante un dizionario con i parametri di rete:
    \begin{itemize}
        \item averageDelta: l'intervallo di tempo delle medie percentuali di traffico da calcolare con l'analizzatore espressi in millisecondi
        \item colorblind: yes/no, abilita nel caso di scelta "yes" una palette cromatica nel visualizzatore grafico adatta a persone affette da daltonismo
        \item dotSize: fixed/adaptive, un'opzione che rende uguale la dimensione a tutti gli elementi raffiguranti gli switch nel visualizzatore grafico (fixed), oppure che adatta la dimensione alla lunghezza dell'identificativo degli switch (adaptive)
        \item graphType: la tipologia del grafo da visualizzare (complete, mesh, torus)
        \item linkCap: valore compreso tra [10, 100, 1000]/mixed, un valore che identifica la capacità dei links qualora fossero tutti della stessa grandezza, mixed altrimenti
        \item packetsFile: json/yaml, la scelta del formato con il quale si vuole memorizzare il traffico di rete
        \item simTime: la durata complessiva delle operazioni di rete
        \item startSimTime: timestamp, data e ora nel formato YY:MM:DD HH:MM:SS dell'inizio della trasmissione del traffico
        \item updateDelta: un intervallo temporale che identifica ogni quanto la media averageDelta debba essere aggiornata
    \end{itemize}
    \item Una lista di liste che descrive la matrice del posizionamento degli switch.Nel caso di scelta di grafo completo questo campo è una lista vuota ([])
    \item Una lista di fasi temporali che descrivono specifici intervalli temporali nel formato "YY:MM:DD HH:MM:SS = descrizione fase"
\end{itemize}
Il generatore crea delle fasi descrittive ogni 10 secondi di simulazione e le memorizza come ultimo valore della lista della struttura network.
Per il file packets abbiamo invece due possibili risultati in base alla scelta fatta nel file di setup \ref{codice:sim_setup_example}, ovvero json e yaml.
Il generatore crea i pacchetti secondo l'assunzione in cui essi vengano registrati in ordine di invio, avremo quindi una struttura corrispondente
a una lista di pacchetti ordinati per timestamp di invio.
Le strutture si presentano come in figura \ref{codice:json_packets_file} per il formato json e in figura \ref{codice:yaml_packets_file} per il formato yaml.
Come vedremo nel prossimo capitolo, questi due files rappresentano l'esatto formato che riesce a leggere l'analizzatore, quindi un utente
che voglia usare l'analizzatore e il visualizzatore grafico dovrà formattare accuratamente i suoi dati come descritto.

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={esempio di packets file in formato json}, label={codice:json_packets_file}]
[
    {
        "A": 1,
        "B": 2,
        "t": "2024-03-22 12:30:00",
        "d": 4000
    },
    {
        "A": 2,
        "B": 1,
        "t": "2024-03-22 12:30:00",
        "d": 4000
    },
    {
        "A": 2,
        "B": 1,
        "t": "2024-03-22 12:30:00",
        "d": 4000
    }
]
\end{lstlisting}
}

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={esempio di packets file in formato yaml}, label={codice:yaml_packets_file}]
  - A: 1
    B: 2
    d: 4000
    t: &id001 2024-03-22 12:30:00
  - A: 1
    B: 2
    d: 4000
    t: *id001
  - A: 1
    B: 2
    d: 4000
    t: *id001
\end{lstlisting}
}

In cui in entrambi i casi abbiamo i seguenti campi:
\begin{itemize}
    \item A: l'endpoint di partenza del pacchetto
    \item B: l'endpoint di arrivo del pacchetto
    \item d: la dimensione del payload del pacchetto espresso in Bytes
    \item t: il timestamp rappresentante la data e l'ora di invio del pacchetto
\end{itemize}
La scelta di usare un solo carattere per descrivere i vari campi può sembrare in contrasto con la volontà di rendere leggibile il tutto,
ma c'è una valida motivazione dietro. Il risparmio di caratteri, in files che sono potenzialmente molto grandi, è un aspetto cruciale sia per quanto
riguarda l'occupazione di memoria, sia per motivi di efficienza. Consideriamo una rappresentazione di un pacchetto più descrittivo come in figura \ref{codice:long_description_packet}:

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={rappresentazione di un pacchetto con descrizione completa}, label={codice:long_description_packet}]
{
    "endpointA": 1,
    "endpointB": 2,
    "timestamp": "2024-03-22 12:30:00",
    "dimension": 1518
}
\end{lstlisting}
}

Avremmo così 37 bytes necessari per i nomi dei campi contro i 4 per la rappresentazione di un pacchetto descritta precedentemente, avendo uno scarto di
33 bytes per pacchetto. Questa quantità, moltiplicata la grande quantità di pacchetti da rappresentare, può pesare non poco.
Indipendentemente dal numero di bytes necessari a rappresentare un pacchetto in forma minimale, possiamo fare una stima di quanto sarebbe più grande
un file packets avendo descrizioni di nomi più lunghi; supponiamo di avere un grafo completo costituito da 5 switch collegati tra loro con switch
aventi capienza 1 Gbps (gigabit), il numero dei link, per l'equazione in fig. \ref{eq:link_number}, risulta essere pari a 10. Supponiamo che tutta la rete
stia trasmettendo al 50\% della sua capacità trasmissiva per tutta la durata dell'attività di rete. Considerando una dimensione \(d\) di payload pari 
a 1518 Bytes uguale per tutti i pacchetti trasmessi,
definiamo come \(pps\) i pacchetti al secondo, da cui, per un link in un dato secondo avremo:
\begin{align*}
    \text{1 Gbps} &= 10^9 \text{ bit}\\
    \text{1 GBps} &= \frac{10^9}{8} = 125,000,000 \text{ bytes} && \text{(1 byte = 8 bit)} \\
    \text{50\% capacity} &= \frac{125,000,000}{2} = 65,500,000 \text{ bytes}\\
    \text{d} &= 1518 \text{ bytes} \\
    \text{pps} &= \frac{65,500,000 \text{ bytes}}{d}\approx 41172.59\\
    \text{bytes di differenza} &= 41172.59 \times 33 \approx 1.35 \text{ MBytes}
\end{align*}
Ciò significa che per ogni secondo di traffico avremmo \(1.35 \text{ MB} \times 10\text{ links} = 13.5 \text{MB}\) in più, 
 in 100 secondi di traffico avremmo 1350 Mbytes, cioè 1.35 GBytes in più per una rete avente soltanto 10 links, quindi con la scelta di rendere
  mono carattere le descrizioni
 si ha un notevole risparmio in termini di data storage. Chiaramente in ottica di espansione futura del progetto, avendo strutture più complesse
 per i pacchetti, potrebbe essere necessario avere elementi maggiormente descrittivi, tuttavia ciò non toglie che una certa cura nella scelta di una 
 descrizione minimale non possa essere comunque adottata in via preferenziale.


 \section{Aspetti realizzativi scartati: yaml flow e block style}
 Un approccio inizialmente realizzato e poi scartato, è stato quello di poter dare la possibilità di scegliere la modalità di salvataggio del file packets.yaml.
La libreria PyYAML permette di salvare un file yaml secondo due modalità; la prima è definita block style e l'altra flow style.
Di default, PyYAML sceglie lo stile di una collection a seconda che abbia a sua volta collection nidificate. Qualora ci fossero collection nidificate
verrà assegnato lo stile block, il quale è il formato come lo abbiamo già visto in figura \ref{codice:yaml_packets_file}, altrimenti verrà assegnato
lo stile flow che corrisponde al codice in figura.

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={rappresentazione di un pacchetto con descrizione completa}, label={codice:long_description_packet}, breaklines=true]
[{A: 2, B: 1, d: 4000, t: &id001 !!timestamp '2024-03-22 12:30:00'}, {A: 1, B: 2,
    d: 4000, t: *id001}, {A: 1, B: 2, d: 4000, t: *id001}, {A: 2, B: 1, d: 4000, t: *id001},
  {A: 2, B: 1, d: 4000, t: *id001}, {A: 2, B: 1, d: 3752, t: *id001}, {A: 1, B: 2,
    d: 4000, t: &id002 !!timestamp '2024-03-22 12:30:00.100000'}, {A: 2, B: 1, d: 4000,
    t: *id002}, {A: 1, B: 2, d: 4000, t: *id002}, {A: 1, B: 2, d: 4000, t: *id002},
  {A: 2, B: 1, d: 4000, t: *id002}, {A: 2, B: 1, d: 3752, t: *id002}, {A: 1, B: 2,
    d: 4000, t: &id003 !!timestamp '2024-03-22 12:30:00.200000'}, {A: 2, B: 1, d: 4000,
    t: *id003}, {A: 2, B: 1, d: 4000, t: *id003}, {A: 1, B: 2, d: 4000, t: *id003},
\end{lstlisting}
}
Inizialmente si era provato a dare la possibilità di scegliere, tramite file sim\_setup, 
tra il formato block e flow poichè in fase di test
si è visto che l'opzione flow riduce ulteriormente la dimensione del file packets.yaml. Tuttavia i test hanno dimostrato che le differenze delle grandezze
dei files e i tempi necessari a realizzarli non erano così diversi tra loro, quindi si è deciso di scartare del tutto l'opzione. Possiamo vedere
il risultato del test sulle dimensioni dei files in figura \ref{fig:yaml_block_flow_dim}, dove troviamo sull'asse delle ascisse il numero di switch per test, mentre
sull'asse delle ordinate abbiamo la variabile che esprime i megabytes, questo perchè essa è la variabile dipendente, ovvero i megabytes dipendono dal numero di switch
che viene scelto. Il grafico relativo ai tempi di scrittura/lettura lo troviamo in 
figura \ref{fig:yaml_block_flow_wr}, in questo caso abbiamo sull'asse delle ascisse sempre il numero di switch per test, mentre sull'asse delle ordinate
il tempo (in secondi) necessario per le scritture e letture, poichè il tempo di computazione dipende dal numero di switch scelto. Possiamo notare dai grafici che il risparmio di bytes è di circa 4 MB per il test effettuato su 10 switch, mentre
i tempi di esecuzione, sia di scrittura che di lettura, sono praticamente sovrapponibili, infatti l'operazione di scrittura per block e flow style è identico, mentre lievemente
più performante è il block style in lettura.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{immagini/yaml_block_flow_dim.png}
    \caption{test yaml block/flow style, dimensione files}
    \label{fig:yaml_block_flow_dim}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{immagini/yaml_block_flow_wr.png}
    \caption{test yaml block/flow style, tempi di scrittura e lettura}
    \label{fig:yaml_block_flow_wr}
\end{figure}




\chapter{Analizzatore di traffico}
L'analizzatore di traffico è la seconda anima del progetto essendo la parte che analizza il traffico calcolando le medie percentuali e che produce
un file, analyzed\_data.yaml, che conterrà sia le informazioni di rete come links, switches e parametri di rete, sia le registrazioni del traffico percentuale
di ogni link. Per poter operare, l'analizzatore ha bisogno dei due files, network.yaml e packets.yaml, creati dal generatore o che siano
creati e formattati dall'utente. Abbiamo descritto in dettaglio la composizione dei files nella sezione \ref{sec:files_prodotti}.
L'esecuzione dello script parte in primo luogo caricando i files richiesti e creando le strutture necessarie al calcolo delle medie, dopodichè
avviene il calcolo vero e proprio, viene creata la struttura che servirà come input del visualizzatore grafico e infine viene creato il file
analyzed\_data.yaml con tale struttura.
Poichè per motivi di efficienza si è scelto di strutturare i link come una lista nel file network.yaml e non come dizionario (in cui ogni link avrebbe avuto un identificativo come chiave), si è presentato il problema dell'identificazione dei link.
I link in fin dei conti possono essere identificati dai propri endpoints (il grafo viene inteso in modo tale che ci sia un unico link tra due endpoints), ovvero una coppia di nodi,
nel nostro caso, una coppia di switch. Tuttavia la sfida che si è presentata è rappresentata dal fatto che se è vero quindi che un link è identificato
da due endpoints, a e b, è vero anche che in questo caso l'ordinamento degli endpoints non deve essere rilevante. Abbiamo infatti pacchetti
che vengono inviati sia da a per poi arrivare a b, sia da b verso a. Questo è un problema poichè stiamo cercando di identificare un link ma abbiamo
due coppie, \((a, b)\) e \((b, a)\) che sì sono ugualmente valide ma rappresentano anche due coppie distinte, il che contrasta con il concetto di identificatore. 
L'ideale sarebbe usare il tipo set, ovvero il concetto di insieme 
come collezione non ordinata in cui due insiemi \(\{b, b\}, \{b, a\}\) sono considerati uguali in termini di contenuto. Sembrerebbe un problema risolto, ma non è così, il perchè risiede
nel fatto che i set in Python sono mutabili: il contenuto può essere modificato utilizzando metodi come add() e remove(). 
Poiché set è mutabile, non ha valore hash \cite{pythonGlossaryHashable} e non può essere utilizzato come chiave del dizionario \cite{pythonStdTypesMapping}.
Il tipo di dato che fa al caso nostro è quindi il frozenset, un set che è immutabile e hashable, quindi utilizzabile come chiave di un dizionario.
Nell'analizzatore l'identificazione dei link è molto importante, perchè nel momento in cui si va a scorrere la lista di tutti i pacchetti registrati,
vi è il bisogno di identificare il link per potergli attribuire le varie medie da calcolare. Viene quindi creata una struttura ausiliaria in cui
la lista di link presente nel file network.yaml viene tramutata in un dizionario avente come chiavi dei frozenset con gli endpoints e, come valori associati,
una serie di variabili atte a mantenere le somme dei pacchetti che man mano verrano scanditi.
Segue la scansione dei pacchetti in cui, per ogni unità frazionaria di tempo dettata dal campo updateDelta presente in network.yaml, vengono sommati tutti i bytes di tutti i pacchetti
e attribuiti ai link corrispettivi.
Una volta finita la scansione, la struttura ausiliaria viene scandita per ricavare le medie percentuali delle varie somme calcolate dal passaggio precedente e viene
creata la struttura che verrà memorizzata in analyzed\_data.yaml. La struttura memorizzata è raffigurata in figura \ref{codice:analyzed_data_structure}.

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={rappresentazione della struttura analyzed\_data}, label={codice:analyzed_data_structure}]
{
  - averageDelta: 1000
    simStartTime: 2024-03-22 12:30:00
    simTime: 2
    updateDelta: 100
  - - endpoints:
      - 1
      - 2
      traffic:
      - 59.0
      - 53.5
      - 48.0
      - 42.5
      - 37.0
      - 31.5
      - 26.0
      - 20.5
      - 15.0
      - 9.5
      - 4.0
    - endpoints:
      - 1
      - 3
      traffic:
      - 33.0
      - 38.8
      - 44.6
      - 50.4
      - 56.2
      - 62.0
      - 67.8
      - 73.6
      - 79.4
      - 85.2
      - 91.0
}
\end{lstlisting}
}

La struttura consiste in una lista di due elementi, il primo è un dizionario rappresentate 
i parametri di rete necessari al visualizzatore grafico, il
secondo è una lista di dizionari rappresentati i link, definiti dal campo enpoints, e le loro medie percentuali memorizzate nel campo traffic.
L'unico campo che non abbiamo ancora incontrato finora è traffic, esso rappresenta le medie percentuali di tempo averageDelta, calcolate ogni updateDelta millisecondi.
Nell esempio in figura \ref{codice:analyzed_data_structure} abbiamo che le medie vengono calcolate quindi in intervalli di 1000 ms (millisecondi), aggiornati ogni
100 ms. Prendiamo ad esempio il primo link identificato dalla coppia di endpoints \((1, 2)\), i suoi valori del campo traffic sono associati ai seguenti tempi:
\newline

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[caption={timestamps e medie percentuali calcolate dall'analizzatore}, label={codice:analyzed_data_structure}]

    2024-03-22 12:30:01 - 59
    2024-03-22 12:30:01.100000 - 53,5
    2024-03-22 12:30:01.200000 - 48
    2024-03-22 12:30:01.300000 - 42,5
    2024-03-22 12:30:01.400000 - 37
    2024-03-22 12:30:01.500000 - 31,5
    2024-03-22 12:30:01.600000 - 26
    2024-03-22 12:30:01.700000 - 20,5
    2024-03-22 12:30:01.800000 - 15
    2024-03-22 12:30:01.900000 - 9,5
    2024-03-22 12:30:02 - 4

\end{lstlisting}
}
I timestamps sono espressi nel formato YY:MM:DD HH:MM:SS.Microseconds, questo per via dell'impiego dell'oggetto timedelta \cite{pythonDatetimeTimedelta} che converte un millisecondo in 1000 microsecondi e con cui è possibile effettuare
operazioni aritmetiche di somma e differenza tra due oggetti datetime \cite{pythonDatetimeTimedelta}.
Il primo valore che abbiamo, \(59\), è quindi la media percentuale dei pacchetti inviati tra il tempo 12:30:00 e 12:30:01, il secondo valore, \(53.3\) è la media
dell'intervallo 12:30:00.100000 e 12:30:01.100000, e così via.
Il file prodotto analyzed\_data.yaml sarà l'input necessario per il visualizzatore grafico, che verrà discusso nel capitolo successivo.

\chapter{Visualizzatore grafico}
La terza anima del progetto è il visualizzatore grafico sviluppato tramite l'ausilio della libreria Manim. Andremo a descrivere il funzionamento dello script,
come è strutturato e organizzato, in seguito descriveremo le modalità grafiche dei grafi che sono possibili ottenere, inclusa la rappresentazione video
delle informazioni relative ai switch e link. Seguirà una sezione sulle scelte di design servite a curare l'aspetto visivo e infine ci sarà spazio
per l'accessibilità inclusa nel progetto che prevede un'opzione per daltonici e che consente quindi di cambiare i colori che rappresentano il traffico.

\section{Strutturazione e organizzazione del visualizzatore}
\label{sec:strutturazione_visualizzatore}
Andremo ora a descrivere come è strutturato il codice a livello logico. La prima cosa che salta all'occhio aprendo il progetto potrebbe essere la riga di codice:

{\scriptsize
\begin{lstlisting}[language=Python]
    from manim import *
\end{lstlisting}
}

Potrebbe sembrare un errore, o una scelta pigra per velocizzare le importazioni delle sezioni di libreria necessaria, ma in realtà questo è proprio
l'uso raccomandato dalla documentazione ufficiale di utilizzare Manim \cite{ManimDocs}.
Una volta avviato lo script verranno caricati i files analyzed\_data.yaml e network.yaml, successivamente verranno impostati i colori del traffico in base
alla scelta fatta nel campo colorblind all'interno del file network, dopodichè possiamo pensare al resto dello script come un bivio in cui ci sono le due funzioni principali;
la funzione che renderizzerà il grafo in caso di grafo completo e la funzione che renderizzerà un grafo pensato per essere disposto
tramite matrice. La funzione relativa al grafo completo sfrutta la potenza di Manim per la disposizione dei nodi e degli archi (links), provvedendo
una disposizione automatica ed organica degli elementi e rappresenta la scelta più indicata per questo tipo di rappresentazione; per
farlo bisogna settare il campo customGraph nel file network al valore "complete" e lasciare il campo "coordinates" vuoto. Per ottenere un grafo
completo con coordinate personalizzate bisognerà assegnare a graphType il valore "graph" e specificare le coordinate nel campo "coordinates". 
Vedremo degli esempi in figura nel paragrafo successivo. Entrambe le funzioni hanno lo stesso pattern di creazione del grafico e di creazione delle animazioni;
prima si costruiscono le strutture da visualizzare, inclusi i parametri di rete da visualizzare, successivamente viene eseguito una iterazione sui timestamps ricavati
dal file analyzed\_data in cui per ogni intervallo di tempo updateTime viene presa la parcentuale corrispondente di ciascun link, 
si prendono i colori associati alle varie percentuali e si crea un'animazione di durata 1 secondo di transizione verso il colore scelto e si ripete 
fino a quando non si arriva a fine simTime.
Per dare una maggiore idea sul come vengono create le forme e le animazioni in Manim faremo una breve introduzione alla libreria.
In Manim ogni oggetto viene definito Mobject, ovvero un "Mathematical Object", e deriva dalla classe di base Mobject, cioè un oggetto che può essere visualizzato a schermo,
per esempio una forma rettangolo, una linea o un cerchio, vengono definiti tutti mobject.
La classe Scene è la tela sul quale si disegnano i mobjects, una volta istanziati essi vanno aggiunti alla Scene per poter essere visualizzati,
ciò e possibile tramite il metodo \lstinline|add()|. Prendiamo il primo esempio fornito dalla documentazione Manim:

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[language=Python, caption={un primo esempio di utilizzo di Manim \cite{ManimDocs}}, label={codice:manim_example}]
{
    from manim import *

    class CreatingMobjects(Scene):
        def construct(self):
            circle = Circle()
            self.add(circle)
            self.wait(1)
            self.remove(circle)
}
\end{lstlisting}
}

Come descrive la documentazione ufficiale, generalmente tutto il codice che descrive un video va all'interno del metodo \lstinline|construct()|
della classe \lstinline|Scene|, per poter visualizzare un mobject si chiama il metodo \lstinline|add()| della \lstinline|Scene| contenuta, in questo caso
passiamo un mobject \lstinline|circle| come parametro, aggiungendolo alla \lstinline|Scene|.
Il metodo \lstinline|wait(1)| fa passare un secondo di tempo e \lstinline|remove(circle)| lo rimuove.
Si intuisce da subito le potenzialità che offre la libreria ma sono le animazioni il cuore di Manim.
Ogni proprietà di un mobject che può essere modificata, può essere animata. Infatti ogni metodo che cambia una proprietà di un mobject può essere
usato come un'animazione tramite l'uso di \lstinline|animate()|.

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[language=Python, caption={un primo esempio di animazioni in Manim \cite{ManimDocs}}, label={codice:manim_animation_example}]
{
    from manim import *

    class AnimateExample(Scene):
        def construct(self):
            square = Square().set_fill(RED, opacity=1.0)
            self.add(square)
    
            # animate the change of color
            self.play(square.animate.set_fill(WHITE))
            self.wait(1)
    
            # animate the change of position and the rotation
            self.play(square.animate.shift(UP).rotate(PI / 3))
            self.wait(1)
}
\end{lstlisting}
}

Nel codice in fig. \ref{codice:manim_animation_example}, vediamo come impostare il colore rosso e il livello di opacità al mobject \lstinline|Square()|,
applicando poi il metodo \lstinline|square.animate.set_fill(WHITE)| viene creata l'animazione di transizione di colore da rosso a bianco.
L'animazione creata deve essere aggiunta alla \lstinline|Scene| per poterla visualizzare e lo si fa tramite \lstinline|play()|.
Questa breve introduzione a Manim ci da già l'idea della potenza che offre ponendo come unico limite la creatività dello sviluppatore.
Ritornando alla descrizione delle funzioni principali, il grafo completo, della funzione dedicata, viene creato tramite la classe
\lstinline|Graph()|, in cui due dei principali parametri richiesti sono una lista di valori che identificano i nomi dei nodi e una lista di coppie (tuple)
che descrivono gli archi (link). Chiaramente la liste degli switch e delle tuple di endpoints vengono create a monte. Per quanto riguarda
la creazione delle animazioni, il cuore risiede in questo pseudocodice:


{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[language=Python, caption={creazione animazione traffico}, label={codice:traffic_animation_example}]
animations.append(grafo.edges[(A, B)].animate.set_color(traffic_color))
\end{lstlisting}
}
In questo pseudocodice abbiamo una lista di animazioni \lstinline|animations|, in cui aggiungiamo un'animazione \lstinline|animate| che interessa l'oggetto arco 
restituito da \lstinline|grafo.edges[(A, B)]| e individuato dalla coppia di endpoints (A, B). Dopodichè definiamo quale proprietà deve essere animata,
 in questo caso l'impostazione di un nuovo colore tramite \lstinline|set_color()| il quale è il colore corrispondente al timestamp correntemente analizzato.
Questa operazione viene effettuata per tutti i link per l'intervallo di tempo updateDelta, quando tutte le animazioni sono settate si usa
il metodo \lstinline|play(animation*)| per animarle tutte conteporaneamente e ciò si ripete per la durata di tempo registrato.

Per quanto riguarda la seconda funzione principale, il pattern di creazione è analogo, tuttavia è interessante descrivere il posizionamento dei nodi.

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[language=Python, caption={creazione posizionamento nodi griglia}, label={codice:grid_nodes_example}]
for row in range(rows):
    for col in range(cols):
        opacity = 1
        # Switches with ID=0 are considered as empty spaces
        if str(mesh[row][col]) == EMPTY_SPACE:
            opacity = 0
        dot = None
        if network_data[CONST.NETWORK["SIM_PARAMS"]]["dotsSize"]=="adaptive":
            dot = LabeledDot(str(mesh[row][col]), 
                            point=np.array([col * spacing, row*-spacing, 0]))
        elif network_data[CONST.NETWORK["SIM_PARAMS"]]["dotsSize"]=="fixed":
            dot = LabeledDot(str(mesh[row][col]), 
                            radius=0.6, 
                            point=np.array([col*spacing, row*-spacing, 0]))
        dot.set_opacity(opacity)
        graph_mesh[mesh[row][col]] = dot
        mesh_grid.add(dot)
\end{lstlisting}
}

Il codice in figura \ref{codice:grid_nodes_example} mostra come vengono creati e disposti i nodi in una griglia. Vengono considerati tutti i valori rappresentanti i nodi (switch)
presenti nel campo coordinates del file network.yaml, anche quelli aventi valori zero, i quali vengono comunque aggiunti ma settati con opacità pari a zero i quali non verranno renderizzati nel risultato finale,
quindi non peseranno in termini computazionali, e fungono da riferimento per i valori adiacenti al pari dei valori diversi da zero.
I nodi sono rappresentati da mobject \lstinline|LabeledDot()|, ovvero dei cerchi pieni con raffigurato al loro interno il valore dell'ID dello switch. Al momento di creazione, nel \lstinline|LabeledDot()|,
viene passato anche un array rappresentante le coordinate [x, y, z] che il nodo dovrà avere. 
Tutti i nodi vengono aggiunti singolarmente in un mobject \lstinline|VGroup()| (variabile mesh\_grid),
ovvero un gruppo che può contenere oggetti vettorializzati.
Per quanto riguarda invece la creazione dei links, la parte che rappresenta il mesh graph è creata tramite mobjects \lstinline|Line()|, i quali
rappresentano rette che congiungono due punti, avremo così i link definiti come segue:

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[language=Python, caption={creazione link}, label={codice:link_creation_example}]
    line = Line(dot_a.get_center(), 
        dot_b.get_center(), 
        color=START_COLOR, 
        stroke_width=8)
\end{lstlisting}
}

Il mobject prende le coordinate dei nodi da collegare come paramtri, oltre al colore di partenza e alla dimesione.
Nel caso di grafo torus si aggiunge il controllo dei nodi posti all'estremità della griglia; qui vi è un controllo preciso circa la tipologia di posizionamento poichè se nell'analizzatore di traffico
avevamo il problema del rappresentare in un unico modo due tuple con ordinamento diverso, 
in questo caso l'ordinamento è molto importante per poter disegnare gli archi dei nodi alle estremità, questo perchè i link che le collegano devono essere disegnati manualmente creando più segementi concatenati.
Il lettore si starà chiedendo se non esistesse un mobject come \lstinline|Line()| per rappresentare dei link arcati, e in effetti uno c'è ed è \lstinline|ArcbetweenPoints()|, il quale funzionamento è esattamente cme \lstinline|Line()|.
Il problema che è sorto in fase di sviluppo è che, per ridimensionare i grafi quando diventano più grandi dell'area di visualizzazione, si è reso neccessario del metodo
 \lstinline|auto_zoom()| della classe \lstinline|MovingCameraScene|, ovvero la scena utilizzata nel progetto che permette cambiamenti di visuale della camera.
Il ridimensionamento generato automaticamente dal metodo va in conflitto con \lstinline|ArcsBetweenPoints()|, creando artifici grafici non desiderati, per cui si è reso necessario questo altrimenti utilissimo mobject.
Si è quindi passati a una realizzazione manuale degli archi che segue la creazione di 3 segmenti concatenati per rappresentare i link del torus dei nodi posti alle estremità.
Perticolare attenzione va data al metodo \lstinline|get_center()| del mobject \lstinline|LabeledDot()|, poichè il metodo ritorna le coordinate del nodo, ci servirà per descrivere come vengono creati i link manuali.
L'idea di creazione deriva dal considere il centro dei nodi delle estremità come punti di origine di piani cartesiani \(x, y\) dai quali ricavare le coordinate dei 3 segmenti, i vari sistemi di coordinate sono;

\begin{itemize}
    \item \textbf{Links verticali:} 
    \begin{itemize}
        \item prima linea: si parte da un nodo posto all'estremità superiore della griglia ottenendo le coordinate con \lstinline|get_center()| e ne definiamo il punto \(pointA\), si prende il punto \(p1 = (-x, -y)\), rispetto alle coordinate di \(pointA\), e si crea la linea che parte da p1 a pointA
        \item seconda linea: si prende il nodo posto all'estremità inferiore della griglia nella stessa colonna in cui è presente \(pointA\), e ricavandone le coordinate con il metodo abbiamo un punto che definiamo come \(pointB\), si prende il punto \(p2 = (-x, y)\), rispetto alle coordinate di \(pointB\), e si crea la linea che parte da p2 a pointB 
        \item terza linea: si crea una linea che va dal punto p1 al punto p2.
    \end{itemize}
    \item \textbf{Links orizzontali:} 
    \begin{itemize}
        \item prima linea: si parte da un nodo posto all'estremità sinistra della griglia ottenendo le coordinate con \lstinline|get_center()| e ne definiamo il punto \(pointA\), si prende il punto \(p1 = (x, -y)\), rispetto alle coordinate di \(pointA\), e si crea la linea che parte da p1 a pointA
        \item seconda linea: si prende il nodo posto all'estremità destra della griglia nella stessa riga in cui è presente \(pointA\), e ricavandone le coordinate con il metodo abbiamo un punto che definiamo come \(pointB\), si prende il punto \(p2 = (-x, -y)\), rispetto alle coordinate di \(pointB\), e si crea la linea che parte da p2 a pointB 
        \item terza linea: si crea una linea che va dal punto p1 al punto p2.
    \end{itemize}

\end{itemize}

Vien da sè che in questo caso è indispensabile l'ordinameto, poichè per ogni specifico nodo ci sono delle specidiche coordinate per la creazione dei link manuali.
Se non si facesse questo tipo di controllo, potremmo avere una situazione come in figura \ref{fig:torus_archi_asimmetrici}, avremmo una situazione
molto disorganica e asimmetrica.


\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{immagini/archi_asimmetrici_torus.png}
    \caption{visualizzazione di archi non ordinati alle estremità di un torus graph}
    \label{fig:torus_archi_asimmetrici}
\end{figure}

Per questo motivo viene eseguito un controllo nel caso di analisi di un grafo torus, con l'algoritmo che scansiona la matrice e seleziona gli a archi che sono verticali, orizzontali
e en assegna le giuste coordinate.
Infinie la parte di animazione è pressoché uguale come logica.
Per quanto riguarda le informazioni della rete che vengono mostrate a schermo si è implementato un effetto contatore sul tempo che scorre ed è presente
un ridimensionamento dinamico dei font che si adatta al crescere del grafico, questo per poter rendere sempre leggibile il testo.
Per visualizzare le informazioni relative agli switch e ai link è stata realizzata una classe apposita, la quale può venire renderizzata separatamente dai grafici.
Il video che produce è una presentazione animata di switch e links, gli switch, correlati con le loro info, vengono mostrati cinque alla volta con un effetto di comparsa e scomparsa, con effetto slide, mostrando poi i successivi cinque switch e relative info.
Una volta terminati gli switch si susseguiranno i link, animanti nello stesso modo e comaprendo otto alla volta, mostrando gli enpoints al quale sono collegati e le capacità. Mostreremo graficamente ciò nel capitolo dedicato alle modalità grafiche.
\section{Modalità grafiche e design}
In questo capitolo si vogliono mostrare tutte le configurazioni grafiche, i modi in cui l'algoritmo adatta gli elementi a schermo e le soluzioni trovate.
Essendo un progetto che si basa fortemente su un aspetto front-end, questo capitolo sarà ficalizzato sul mostrare visivamente cosa può produrre il visualizzatore nelle varie configurazioni possibili.
Partiamo con la scelta di design dei colori che rappresentano le intensità di traffico; la scelta è ricaduta su colori ai quali generalmente associamo significati abitudinari e comuni,
come il verde per indicare traffico zero o basso, per poi arrivare al giallo per indicare un traffico di intensità media, fino ad arrivare al rosso
per indicare il traffico molto intenso o massimo. Le varie gradazioni sono calcolate a partire da valori rgb e distribuiti su una scala che va da 1 (verde) a 100 (rosso), modificando opportunamente le graduazioni intermedie a cavallo tra le diverse colorazioni.
Parlando invece del grafo completo, come descritto precedentemente, un grafo completo può essere disposto in modo automatico e imposto tramite coordinate dei nodi dall'utente. 
Considerandone un esempio, sulla base dello stetto packets file, i due modi di visualizzare il grafo completo possono apparire come nella fig. \ref{fig:custom_complete_autopositioning} per l'auto-posizionamento e come in fig \ref{fig:custom_complete_manual_positioning} per il posizionamento manuale.


\begin{figure}[h]
    \centering
    \begin{minipage}{0.46\textwidth}
      \includegraphics[width=\linewidth]{immagini/custom_complete_autopositioning.JPG}
      \caption{visualizzazione per opzione grafo completo con disposizione automatica}
      \label{fig:custom_complete_autopositioning}
    \end{minipage}\hfill
    \begin{minipage}{0.47\textwidth}
      \includegraphics[width=\linewidth]{immagini/custom_complete_manual_positioning.JPG}
      \caption{visualizzazione per opzione grafo completo con coordinate personalizzate}
      \label{fig:custom_complete_manual_positioning}
    \end{minipage}
\end{figure}


La scelta di design dietro la visualizzazione del grafo completo in modo circolare è stata fatta per motivi di leggibilità, Manim propone diversi
layout di configurazione, come possiamo vedere dall'immagine presa dalla documentazione ufficiale \cite{manimGraph} in fig. \ref{fig:graph_layouts_types}. Dagli esempi
si nota subito che l'opzione circolare è quella meglio distribuita, il che è ragionevolmente utile quando si tratta di disegnare molti elementi a schermo. 
I layouts possibili come scelta sono, in ordine di apparizione; spring, circular, kamada kawai, planar, random, shell, spectral e spiral.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/graph_layouts_types.png}
    \caption{layouts possibili per Graph()}
    \label{fig:graph_layouts_types}
\end{figure}


Un esempio di grafo completo con modalità auto, settato con 10 switch in modalità circular, lo troviamo in figura \ref{fig:custom_complete_autopositioning10}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/auto_complete_10.JPG}
    \caption{visualizzazione grafo completo con disposizione automatica di 10 switch}
    \label{fig:custom_complete_autopositioning10}
\end{figure}

Come abbiamo detto nella sezione \ref{sec:aspect_ratio}, la modalità auto gestisce l'aspect ratio sulla base del numero di switch scelti,vi sono quindi
due risultati possibili di visualizzazione; il primo è che il numero di switch combacia con il calcolo dell'aspect ratio e fornisce una riempimento
completo della matrice da visualizzare (già visto nel capitolo \ref{sec:esecuzione_del_generatore} in fig. \ref{fig:mesh_example}), 
il secondo coincide con un riempimento parziale e in questo caso l'algoritmo lascerà semplicemente dello spazio vuoto (fig. \ref{fig:mesh_not_full}).
La figura \ref{fig:mesh_not_full} mostra inoltre il comportamento del grafo qualora si decidesse di settare il parametro \lstinline|fixedDots| al valore \lstinline|fixed|, 
il quale rende la dimensione dei nodi uguale per tutti, la stessa tipologia di grafo con il parametro settato ad \lstinline|adaptive| adatterà la dimensione dei nodi
in base all'ID con il quale vengono rappresentati, possiamo vedere un esempio in figura \ref{fig:adaptive_dots_example}


\begin{figure}[h]
    \centering
    \begin{minipage}{0.48\textwidth}
      \includegraphics[width=\linewidth]{immagini/mesh_not_full.JPG}
      \caption{visualizzazione grafo mesh completo, opzione dotsSize posta a fixed}
      \label{fig:mesh_not_full}
    \end{minipage}\hfill
    \begin{minipage}{0.48\textwidth}
      \includegraphics[width=\linewidth]{immagini/adaptive_dots_example.JPG}
      \caption{visualizzazione grafo mesh con opzione dotsSize posta ad adaptive}
      \label{fig:adaptive_dots_example}
    \end{minipage}
\end{figure}

La logica di riempimento vale anche per il torus graph (fig.), con l'unica differenza che nel caso di mancato riempimento vengono collegati solo i nodi
che risultano essere posti alle estremità (fig. ). Questa soluzione ibrida segue la convenzione per cui generalmente il torus graph è inteso come completo,
ovvero che riempie tutte le posizioni della matrice imamginaria sul quale ci sono i nodi.



\begin{figure}[h]
    \centering
    \begin{minipage}{0.48\textwidth}
      \includegraphics[width=\linewidth]{immagini/torus_full_24.JPG}
      \caption{grafo torus completo}
      \label{fig:torus_full_24}
    \end{minipage}\hfill
    \begin{minipage}{0.48\textwidth}
      \includegraphics[width=\linewidth]{immagini/torus_not_full_adaptive.JPG}
      \caption{grafo torus non completo}
      \label{fig:torus_not_full_adaptive}
    \end{minipage}
\end{figure}

Osservando gli esempi del torus graph, si può notare come i link dei nodi delle estremità siano meno spesso degli altri che formano la griglia.
Questa è scelta di design volta a rendere maggiormente leggibile il grafo; in questo modo si percepisce subito la tipologia di link a un primo sguardo e il
posizionamento dei punti che definiscono i link sono stati studiati appositamente per fare in modo che non si sovrapponessero, mantenendo l'immagine pulita e organizzata.
Per quanto riguarda la scelta di design dietro il testo visualizzato a schermo, è stato scelto di suddividere le informazioni e distribuirne in due gruppi, uno posto nel margine superiore e l'altro in quello inferiore;
il motivo è per dare enfasi al grafico, che rimane centrale nell'economia dell'esperienza, in questo modo il focus principale rimane sul protagonista della scena, mentre i parametri descrittivi della rete
sono presenti in modo tale da non essere invasivi.
Infine abbiamo la modalità "graph", la modalità in cui l'utente può scegliere dove posizionare i nodi come già visto in fig \ref{fig:tree_custom}
Il visualizzatore possiede anche una modalità per generare un video in cui si mostrano le informazioni degli switch 
e nei nodi come spiegato nella sezione precedente \ref{sec:strutturazione_visualizzatore}. Per dare un'idea di come viene mostrato, riportiamo due frammenti di video in cui vengono mostrate
le varie tipologie di dati (fig. \ref{fig:switch_info} e fig. \ref{fig:links_info}).
\newline
\newline


\begin{figure}[ht]
    \centering
    \begin{minipage}{0.48\textwidth}
      \includegraphics[width=\linewidth]{immagini/switch_info.JPG}
      \caption{switch info}
      \label{fig:switch_info}
    \end{minipage}\hfill
    \begin{minipage}{0.48\textwidth}
      \includegraphics[width=\linewidth]{immagini/links_info.JPG}
      \caption{link info}
      \label{fig:links_info}
    \end{minipage}
\end{figure}

\section{Accessibilità: modalità daltonismo}
In un'applicazione in cui i colori sono parte integrante dell'esperienza, è più che opportuno approcciarsi alla progettazione tenendo
in considerazione delle possibili implementazioni che possano affrontare la questione del daltonismo. 
Il daltonismo è una condizione in cui l'occhio umano presenta cecità ereditaria verso uno o più colori. Le forme più comuni sono:
\begin{itemize}
    \item \textbf{protanopia:} sensibilità deficitaria per il colore rosso.
    \item \textbf{deuteranopia:} sendibilità deficitaria per il colore verde.
    \item \textbf{tritanopia:} sensibilità deficitaria per i colori giallo e blu.
\end{itemize}
Come detto nel capitolo precedente, utilizziamo
i colori verde, giallo e rosso per esprimere rispettivamente basso, medio e alto traffico; andando a vedere le varie tipologie più comuni di daltonismo, 
notiamo da subito che i colori scelti non sono adatti a tutti i tipi di daltonismo. Si è pensato quindi di introdurre l'opzione
\lstinline|colorBlind| che se posta su "yes" cambia i colori in verde per un basso traffico, bianco per traffico medio e fucsia per alto traffico.
Il colore bianco e nero sono visti in egual modo da tutti, questo è anche il motivo per cui lo sfondo del visualizzatore è proprio nero, quindi si è
deciso di utilizzare il bianco come uno dei colori adatti, mentre per gli altri colori si è fatto ricorso al tool "Coloring for Colorblindness" \cite{ColorBlindPalette2024} 
del Professor Nichols, docente dell' Universita del Connecticut, il quale permette di visualizzare una palette cromatica nel modo in cui i vari tipi
di daltonismo si manifestano. Mostriamo le due palette cromatiche, quella di default \ref{fig:palette_cromatica} e quella scelta per l'opzione daltonismo \ref{fig:colorblind_palette}.

\begin{figure}[h]
    \centering
    \begin{minipage}{0.48\textwidth}
      \includegraphics[width=\linewidth]{immagini/palette_cromatica.JPG}
      \caption{palette cromatica di default}
      \label{fig:palette_cromatica}
    \end{minipage}\hfill
    \begin{minipage}{0.48\textwidth}
      \includegraphics[width=\linewidth]{immagini/colorblind_palette.JPG}
      \caption{palette cromatica daltonismo}
      \label{fig:colorblind_palette}
    \end{minipage}
\end{figure}

Come possiamo notare dalle palette cromatiche, quella di default costituirebbe un crosso problema visivo per chi è affetto da protanopia e da deuteranopia, avendo
una selezione di colori davvero molto simili tra loro non si potrebbe distinguere efficacemente il livello di traffico. La soluzione proposta
risiede nella palette cromatica per daltonismo, in cui i colori scelti si riescono a differenziare per ogni tipologia di condizione visiva, potendo così
attribuire al colore verde un livello di traffico nullo o basso, bianco per traffico medio e fucsia per traffico alto o massimo. Un esempio
del risultato finale lo possiamo vedere in figura \ref{fig:colorblind_torus}.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{immagini/colorblind_torus.JPG}
    \caption{opzione colorblind per torus graph}
    \label{fig:colorblind_torus}
\end{figure}

\chapter{Prestazioni e complessità computazionale}

Andremo ora ad analizzare le complessità computazionali dei vari componenti del progetto, mostrando anche le prestazioni ottenute in fase di test.

\section{Generatore di traffico}
Analizzando il codice inerente al generatore, un approccio allo studio della complessità potrebbe essere quello di individuare quelle che si ritengono essere
i punti computazionalmente critici, al fine di individuare l'andamento degli algoritmi nelle varie situazioni. Essendo lo script dedicato alla creazione della struttura di rete e del traffico,
è stato ritenuto opportuno cominciare l'analisi dalla creazione della struttura inerente ai link.
Per quanto riguarda la creazione automatica dei links e dei nodi
per la tipologia di grafo completo, la funzione dedicata al compito è riportata in figura \ref{codice:create_auto_complete_links}

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[language=Python, basicstyle=\ttfamily, caption={funzione per la creazione automatica di un grafo di rete completo}, label={codice:create_auto_complete_links}]
    def create_auto_complete_links(link_cap, switch_number):
    """ Create links for a complete graph 
    
    Key arguments:
    link_cap: int -- link capacity
    switch_number: int -- switch number

    Returns
    dict -- links representation
    """
    # The arcs representing the links connecting the switches (nodes)
    links = {}
    # The link ID counter
    link_id = 1

    for i in range(1, switch_number + 1):
        for p in range(i, switch_number + 1):
            if i != p:
                if link_id not in links:
                    links[link_id] = link_format(i, p, link_cap)
                    link_id += 1
    return links
\end{lstlisting}
} % Fine del gruppo che modifica la dimensione del testo

Poichè in questo caso il numero di link può essere molto elevato, consideriamo il numero di link come \(n\) essendo il ciclo for esterno condizionato
dal numero di switch. Ma se osserviamo bene notiamo che il ciclo interno parte dall'indice del ciclo for esterno. Non avremo quindi n iterazioni moltiplicato n,
ma avremo una quantità di iterazioni totali pari a:

\begin{equation}
    O\left(\sum_{i=1}^n (n-i)\right)
\end{equation}

Che andando a sviluppare risulterà essere:
\begin{align}
    O\left(\sum_{i=1}^n (n-i)\right) &= O\left(\sum_{i=1}^n n - \sum_{i=1}^n i\right) \\
    &= O\left(n\sum_{i=1}^n 1 - \sum_{i=1}^n i\right) \\
    &= O\left(n \cdot n - \frac{n(n+1)}{2}\right) \\
    &= O\left(n^2 - \frac{n^2 + n}{2}\right) \\
    &= O\left(\frac{2n^2 - n^2 - n}{2}\right) \\
    &= O\left(\frac{n^2 - n}{2}\right) \\
    &= O(n^2) \quad
    \end{align}
Poiché il termine lineare è dominato dal termine quadratico per grandi \( n \). Ciò è in linea con la grandezza intrinseca del numero di links
per un grafo completo, come visto nell'equazione \ref{eq:link_number}, per cui siamo obbligati a una complessità quadratica.
Tuttavia possiamo osservare dal calcolo:
\begin{align*}
    \sum_{i=1}^n (n-i) &= \frac{n^2 - n}{2} = \frac{n(n-1)}{2}
\end{align*}
    
IL che è esattamente l'equazione \(\frac{n(n-1)}{2}\) che determina il numero di links in un grafo completo. Con questo vogliamo dire che 
l'algoritmo performa esattamente il numero di iterazioni necessarie a creare i link, ottimizzando al massimo le risorse computazionali.
Vi sono poi le varie funzioni dedicate alla creazione delle strutture mesh, torus e graph (la modalità libera), le quali sono tutte basate sul concetto di
disporre i nodi su una matrice (griglia).
Analizziamo la funzione dedicata alla creazione automatica di un grafo mesh.

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[language=Python, basicstyle=\ttfamily, caption={funzione per la creazione automatica di un grafo mesh}, label={codice:create_auto_mesh_links}]
    def create_auto_mesh_links(link_cap, switch_number):
    """ Auto detect links """
    data_links = {}
    link_id = 1

    side = math.sqrt(switch_number)
    # 16/9 aspect ratio
    rows = math.ceil(side * (3/4))
    cols = int(side * (4/3))

    if (rows * cols) < switch_number:
        cols += 1

    switches = [[0 for _ in range(cols)] for _ in range(rows)]
    switch_cont = 1
    for r in range(0, rows):
        for c in range(0, cols):
            if(switch_cont > switch_number):
                break
            switches[r][c] = switch_cont
            switch_cont += 1

            if c > 0:
                data_links[link_id] = link_format(switches[r][c-1], 
                                                  switches[r][c], 
                                                  link_cap)
                link_id += 1
            if r > 0:
                data_links[link_id] = link_format(switches[r-1][c], 
                                                  switches[r][c], 
                                                  link_cap)
                link_id += 1
        if(switch_cont > switch_number):
            break
    return data_links, switches
\end{lstlisting}
} % Fine del gruppo che modifica la dimensione del testo

Come possiamo vedere nel codice \ref{codice:create_auto_mesh_links}, la condizione che domina la complessità è rappresentata dai due cicli \texttt{for} annidati mentre il resto delle
operazioni viene effettuato in tempo costante. I cicli \texttt{for} vendono effettuati sui valori rows e cols, i quali sono derivati dalla radice quadrata nel numero di switch. 
Nel caso di questa applicazione, in cui è permesso un massimo di 1000 switch, la complessità risulta essere in tempo costante, 
poichè nel caso peggiore il valore 1000 è considerabile come costante \(c\), 
avremmo un numero di iterazioni pari a  \( \sqrt{c} \times \sqrt{c} = c \).
Tuttavia lo sarebbe anche se il numero di switch fosse \(n\) 
(con \(n\) molto grande). Consideriamo i due cicli \texttt{for} annidati, ognuno dei quali itera fino alla radice quadrata di \( n \):
\begin{verbatim}
for i in range(sqrt(n)):
    for j in range(sqrt(n)):
        # operazioni
\end{verbatim}
Poiché ogni ciclo itera \( \sqrt{n} \) volte, il numero totale di iterazioni è \( \sqrt{n} \times \sqrt{n} = n \). Pertanto, la complessità computazionale è \( O(n) \).
Analizziamo la funzione dedicata alla creazione automatica di un grafo torus.

{\scriptsize % Cambia la dimensione del testo per il blocco lstlisting
\begin{lstlisting}[language=Python, basicstyle=\ttfamily, caption={funzione per la creazione automatica di un grafo torus}, label={codice:create_auto_torus_links}, breaklines=true]
    def create_auto_toro_links(link_cap, switch_number):
    """ Torus graph links auto generator """
    links, switches = create_auto_mesh_links(link_cap, switch_number)
    rows = len(switches)
    cols = len(switches[0])
    links_id = len(links) + 1
    linkList = []

    for _, content in links.items():
        linkList.append(content["endpoints"])
    
    for i in range(cols):
        if switches[0][i] != 0 and switches[rows-1][i] != 0 and [switches[0][i],switches[rows-1][i]] not in linkList:
            links[links_id] = link_format(switches[0][i], switches[rows-1][i], link_cap)
            links_id += 1

    for i in range(rows):
        if switches[i][0] != 0 and switches[i][cols-1] != 0 and [switches[i][0], switches[i][cols-1]] not in linkList:
            links[links_id] = link_format(switches[i][0], switches[i][cols-1], link_cap)
            links_id += 1

    return links, switches
\end{lstlisting}
} % Fine del gruppo che modifica la dimensione del testo

La funzione \ref{codice:create_auto_torus_links}, si serve del codice di creazione mesh graph automatica\ref{codice:create_auto_mesh_links} per 
creare i link interni alla struttura e successivamente itera prima sulle colonne per individuare i link che collegano i nodi dell' estremità superiore della matrice con quelli dell'estremità inferiore e,
successivamente, itera sulle righe per fare la stessa cosa con i nodi posti alle estremità laterali.
Calcolando la complessità abbiamo, il costo computazionale della funzione di creazione automatica dei link di un mesh graph \(O(c)\), il quale
viene sommato al costo del primo ciclo \(O(\sqrt{c})\) e al costo del secondo ciclo \(O(\sqrt{c})\) mentre tutte le altre operazioni hanno tempo costante.

\[
    O(c) + O(\sqrt{c}) + O(\sqrt{c}) = O(c + \sqrt{c} + \sqrt{c}) = O(c + 2\sqrt{c}) = O(c)
\]

Tuttavia nel caso ipotetico si abbia un numero elevato di switch, la complessità risulterebbe lineare poichè il calcolo rimarrebbe invariato, con la soltanto
eccezione di avere \(n\) al posto della costante \(c\).
Passando alle funzioni user per la creazione dei link troviamo che le funzioni dedicate per il mesh e torus graph sono logicamente molto simili a quelle auto, con
la differenza che in quelle user ci sono dei controlli legati all'inserimento dei valori numerici dei nodi e degli zeri per gli spazi vuoti, sono quindi tutte operazioni che hanno un tempo costante,
quindi queste funzioni hanno la stessa complessità delle controparti auto analizzate precedentemente.
Diverso il discorso per la funzione per tipo di grafo personalizzato, qui la logica è molto più semplice
poichè essendo già tutto descritto nel custom file, si tratta soltanto di ricopiare la struttura dei links così come rappresentata nel file,
quindi in un caso peggiore in cui ci sia un numero elevato \(n\) di links la complessità sarà lineare.

Successivamente alla creazione dei link, la struttura critica è la creazione dei pacchetti in quanto il loro numero può essere davvero grande.

{\scriptsize
\begin{lstlisting}[language=Python, basicstyle=\ttfamily, caption={logica creazione pacchetti}, label={codice:create_packets}, breaklines=true]
for fractional_unit in range(0, SIM_TIME * creationRate):
    # Changing trafficPercentage every second
    if fractional_unit % creationRate == 0:
        for link, content in links.items():
            content["trafficPerc"] = config_gen_utils.change_traffic_perc(content["trafficPerc"], setup["trafficVariation"])
    ENDP_A = 0
    ENDP_B = 1
    for link, content in links.items():
        trafficPerc = content["trafficPerc"]
        # Packets Per Second
        PPS = ((content["capacity"] * 1e6) / 8) / PACKET_SIZE
        timeWalker_toStore = None
        if setup["packetsFile"] == "json":
            timeWalker_toStore = str(timeWalker) # json non parsa i datetime!
        else:
            timeWalker_toStore = timeWalker
        for i in range(0, int((PPS*(trafficPerc/100))/creationRate) ):
            packet = config_gen_utils.create_packet(content["endpoints"][ENDP_A],
                                         content["endpoints"][ENDP_B],
                                         timeWalker_toStore,
                                         PACKET_SIZE)
            packets.append(packet)
        remaining_packets, _ = math.modf((PPS*(trafficPerc/100))/creationRate)
        if remaining_packets != 0:
            remaining_packet_size = int(round(remaining_packets, 3) * PACKET_SIZE)
            packet = config_gen_utils.create_packet(content["endpoints"][ENDP_A],
                                         content["endpoints"][ENDP_B],
                                         timeWalker_toStore,
                                         remaining_packet_size)
            packets.append(packet)
    timeWalker += timedelta(milliseconds=PC_DELTA)
\end{lstlisting}
}

Nel codice \ref{codice:create_packets}, il ciclo esterno che dipende da \lstinline|SIM_TIME * creationRate|, sim time è il tempo totale della simulazione di generazione pacchetti, 
il quale dipende da quanto si vuol fare durare la generazione. La variabile \lstinline|creationRate| rappresenta in quante parti è suddiviso un secondo, questo è dato
dalla scelta del parametro creationDelta del file di setup e che indica la frequenza temporale di creazione dei pacchetti, quindi il ciclo dipende dalla quantità di frazioni temporali in cui si generano i pacchetti.
Questi paramentri non sono grandi ai fini del progetto, supponendo di avere un sim time di 3600 secondi (un'ora), creationDelta posto a 100 millisecondi e un creationRate di 10 dato da: 

\begin{equation}
    \text{creationRate} = \frac{1 \text{ sec}}{\text{creationDelta}} = 10 
    \label{eq:creation_rate_example}
\end{equation}

Ne ricaviamo un valore pari a 36000, il quale può essere considerato una costante. Il secondo ciclo che troviamo è all'interno del primo costrutto \lstinline|if|, il quale scandisce tutti i link per cambiarne le percentuali di traffico da creare; il caso peggiore qui è il caso di grafo completo avente un numero di link
riportato nell'equazione \ref{eq:link_number}, quindi con complessita quadratica, tuttavia è bene precisare che il progetto vuole rappresentare maggiormente la rete in un data center, la quale nella realtà non è mai costruita come un grafo completo poichè i costi sarebbero proibitivi e la complessità aumenta notevolmente, piuttosto è comune avere delle 
rappresentazioni come il grafo mesh o torus, per questo motivo d'ora in poi consideremo numerazioni di links e nodi legati soltanto a questi due tipi di grafi. Analizzando i grafi mesh e torus troviamo che la quantità di link che possiamo considerare è costante, infatti
se consideriamo \(n\) il numero di switch, troviamo che il numero \(l\) di link di un grafo torus è dall'equazione:
\begin{equation}
    l = \frac{4n}{2} = 2n
    \label{eq:torus_link_number}
\end{equation}

Poichè ogni nodo ha 4 nodi adiacenti che vengono contati due volte. Essendo il grafo torus più ricco di links rispetto al grafo mesh, definisce il caso peggiore tra i due risultando così \(O(\frac{4c}{2}) = O(c)\), essendo il numero di switch massimo pari a 1000 quindi costante.
Una precisazione sulla funzione \lstinline|change_traffic_perc()|, la quale opera in tempo costante poichè ha solo il compito di cambiare il valore di percentuale di traffico.
Il secondo ciclo che troviamo ha all'interno un altro ciclo, il primo itera sempre sui links, il secondo itera per il numero di pacchetti da creare, dato un certa percentuale di traffico, in una data frazione temporale.
Troviamo quindi che la variabile PPS (che indica il numero di pacchetti al secondo massimi che un link può trasportare), può essere molto grande, è quindi il nostro \(n\).
Possiamo quindi affermare che il parametro dominante per la complessità sia:

\begin{align}
    O(\frac{\text{PPS}(\frac{\text{trafficPerc}}{100})}{\text{creationRate}}) = O(\frac{cn}{c}) = O(n)
    \label{eq:packets_per_fractional_time}
\end{align}

La funzione \lstinline|create_packet()| opera in tempo costante poichè semplicemente formatta in modo corretto il pacchetto da salvare, così come operano in tempo costante tutte le restanti operazioni.
Facendo quindi una somma di tutte le complessità riguardanti i punti critici \ref{codice:create_packets_complexity} troviamo che la complessità di questo pezzo logico di codice è \(O(n)\) \ref{eq:complexity_traffic_generator}, quindi lineare.

{\scriptsize
\begin{lstlisting}[language=Python, basicstyle=\ttfamily, caption={complessità della logica di creazione pacchetti}, label={codice:create_packets_complexity}, breaklines=true]
O(c)    for fractional_unit in range(0, SIM_TIME * creationRate):
O(1)        if fractional_unit % creationRate == 0:
O(c)            for link, content in links.items():
O(1)                content["trafficPerc"] = config_gen_utils.change_traffic_perc(content["trafficPerc"], setup["trafficVariation"])
O(1)        # operazioni
O(c)        for link, content in links.items():
O(1)            # operazioni
O(n)            for i in range(0, int((PPS*(trafficPerc/100))/creationRate)):
O(1)                # operazioni
O(1)         # operazioni
O(1)    # operazioni
\end{lstlisting}
}

Tirando le somme, la complessità globale per il generatore può dirsi essere lineare, come lo mostrano anche i test effettuati in figura \ref{fig:prestazioni_config_gen}.
I test hanno come parametri un tempo di generazione pari a due secondi, link con capacità di 1 Gbps in un grafo di tipo torus.
Si può vedere che all'aumentare del numero di nodi (switch) il tempo necessario a generare i pacchetti cresce in modo lineare.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{immagini/prestazioni_config_gen.png}
    \caption{Prestazioni per il generatore di traffico}
    \label{fig:prestazioni_config_gen}
\end{figure}



\begin{align}
    O(c(c+cn)) = O(c^2 + c^2n) = O(n)
    \label{eq:complexity_traffic_generator}
\end{align}



\section{Analizzatore di traffico}
Il cuore dell'analizzatore è la parte logica di codice incaricata di scandire tutti i pacchetti, estrarne le somme dei valori di payload e relative vedie percentuali.
L'analizzatore in primis carica i due files network.yaml e packets.json/yaml, in questo caso creiamo sempre una struttura ausiliaria necessaria a memorizzare man mano le somme pei payload; ciò 
consiste semplicemente in un ciclo for che scandisce la lista di link presente nel network file e quindi abbiamo tempo costante O(c), ricordando che stiamo
analizzando come caso peggiore un numero di link presenti un un torus graph, come mostrato precedentemente in fig. \ref{eq:torus_link_number}.
Analizziamo ora il codice \ref{codice:analyze_packets} in cui avviene l'analisi vera e propria.

{\scriptsize
\begin{lstlisting}[language=Python, basicstyle=\ttfamily, caption={logica analisi pacchetti}, label={codice:analyze_packets}, breaklines=true]
    # Every loop is an analyzed fractional unit
    while timeWalker <= startTime + (simTime - updateDelta):
        # For each updateDelta reset values
        for link, content in links.items():
            # Reset traffic
            content["trafficUDT"] = 0
        # Identify the link belonging to the analyzed packet
        if packet is not None:
            link = links[frozenset({packet["A"], packet["B"]})]
            # Analyzing every packet in the analyzed range
            print("analyzing time: ", packet["t"])
            packetTimestamp = None
            if networkData[SIM_PARAMETERS]["packetsFile"] == "json":
                packetTimestamp = utils.str_to_datetime(packet["t"])
            else:
                packetTimestamp = packet["t"]
            while packetTimestamp >= timeWalker and packetTimestamp < timeWalker + updateDelta:
                link["trafficUDT"] += packet["d"]
                link["trafficDT"] += packet["d"]
                packet = next(packetsDataIterator, None)
                if packet is not None:
                    if networkData[SIM_PARAMETERS]["packetsFile"] == "json":
                        packetTimestamp = utils.str_to_datetime(packet["t"])
                    else:
                        packetTimestamp = packet["t"]
                    link = links[frozenset({packet["A"], packet["B"]})]
                else:
                    break
        # Pushing forward the analyzing time
        timeWalker += updateDelta
        # Storing the fractional time units values
        for link, content in links.items():
            content["updateDeltaTraffic"].append(
                {"updateTime": timeWalker, "traffic": content["trafficUDT"]}
            )
    
        # Storing the averageDelta units value
        # If the averageDelta average is not the first one
        if timeWalker > startTime + averageDelta:
            for link, content in links.items():
                # Calcolate the element index to subtract from `updateDeltaTraffic`
                index = (len(content["updateDeltaTraffic"]) - 1) - lastFirstUDindex
                # Traffic value to subtract from the averageTraffic
                traffic_to_subtract = content["updateDeltaTraffic"][index]["traffic"]
                content["trafficDT"] -= traffic_to_subtract
                content["traffic"].append({"updateTime": timeWalker, "traffic": content["trafficDT"]})
        # Else if the averageDelta average is the first one:
        # in this case we don't need to subtract an updateDeltaTraffic
        elif timeWalker == startTime + averageDelta:
            for link, content in links.items():
                content["traffic"].append({"updateTime": timeWalker, "traffic": content["trafficDT"]})
\end{lstlisting}
}

Il primo ciclo while scandisce semplicemente le unità frazionarie temporali scandite da updateTime, come visto precedentemente con l'esempio in fig. \ref{eq:creation_rate_example}, ciò comporta un numero di iterazioni \(O(c)\).
Segue un ciclo for che itera sui link, anche qui abbiamo una complessità di \(O(c)\). Dopo divere operazioni con tempo O(1), la parte che merita attenzione è il ciclo while nidificato.
Questo ciclo itera su tutti i pacchetti che hanno un timestamp che ricade nell'unità frazionaria di tempo da analizzare, sono quindi tutti i pacchetti in un dato updateDelta per un dato traffico percentuale; abbiamo già incontrato questo
parametro e ne abbiamo calcolato il peso in termini computazionali nell' equazione \ref{eq:packets_per_fractional_time}, ottenendo \(O(n)\). Dopo diverse
operazioni, tutte con complessità O(1), i cicli che troviamo sono tre, interessano iterazioni sui link, ciascuno con complessità \(O(c)\), e non sono annidati poichè si susseguono.
Possiamo quindi definire la complessità compelssiva di questa parte logica che risulta essere lineare. \ref{eq:complexity_analyzer}.


\begin{align}
    O(c(c+n+c+c)) = O(c^2 + cn + c^2 + c^2) = O(c + n) = O(n)
    \label{eq:complexity_analyzer}
\end{align}

Un'evenutale conferma arriva dai test dove possiamo vedere l'andamento lineare nel grafico \ref{fig:prestazioni_analizzatore}. Possiamo
notare che all'aumentare del numero di switch nella rete, il tempo cresce in modo lineare.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/prestazioni_analyzer.png}
    \caption{prestazioni dell'analizzatore}
    \label{fig:prestazioni_analizzatore}
\end{figure}



\section{Visualizzatore grafico}
Analizzando il visualizzatore troviamo che il cuore da analizzare ricade sulla parte di codice che crea le animazioni. Nel creare le strutture necessarie, caricandole dai files,
troviamo le stesse complessità computazionali ricavate per i precedenti moduli sofware, mentre per la creazione della base di partenza grafica abbiamo
la funzione \lstinline|Graph()| per disegnare i grafi completi mentre abbiamo il codice visto in fig. \ref{codice:grid_nodes_example} per i grafi mesh, torus e personalizzato.
Per quanto riguarda \lstinline|Graph()| rimane valida l'analisi di complessità quadratica per via nel calcolo del numero di link in un grafo completo, mentre per la creazione delle altre tipologie di grafo
osserviamo dalla fig. \ref{codice:grid_nodes_example} che la complessità è costante, essendo riproposti due cicli annidati che iterano sulla radice quadrata
del numero di nodi. 
Analizziamo quindi la logica che risulta maggiormente critica, la creazione delle animazioni che,
per motivi di lunghezza del codice sarà descritto come pseudocodice:

{\scriptsize
\begin{lstlisting}[language=Python, basicstyle=\ttfamily, caption={logica creazione animazioni}, label={codice:create_animation}, breaklines=true]
while time_walker <= end_time:
    animations = []
    # definig all the traffic color links at timeWalker time
    for content in traffic_data[CONST.ANALYZED_DATA["TRAFFICS"]]:
        color_perc = int(content["traffic"][traffic_count])
        animations.append(animation for the link in content)
    # playing animations
    if(time_walker == phase_time):
        self.play(every traffic animation and the changing phases text animation)
    else:
        self.play(every traffic animation)
    traffic_count += 1
    # pushing forward sim time to check
    time_walker += timedelta(milliseconds=show_delta)
\end{lstlisting}
}

Il primo ciclo while itera su ciscuna unità frazionaria, il quale numero sappiamo essere costante, quindi \(O(c)\), vengono scanditi i link nel for interno andando a prendere il valore del traffico percentuale per l'unità frazionaria analizzata, abbiamo quindi \(O(c)\).
Si disegnano le animazioni e il resto sono operazioni con complessità \(O(1)\). La libreria non dichiara la complessità che può interessare il metodo \lstinline|play()|, tuttavia
i parametri di ingresso rappresentano principalmente una lista di animazioni e diversi mobject di tipo \lstinline|Text()|. 
La complessità in questo caso possiamo ricavarla dai test, i quali mostrano che l'algoritmo opera, nella sua interezza, in tempo lineare.


\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/720p_rendering_performance.png}
    \caption{prestazioni per video con risoluzione di 720p a 30 fps}
    \label{fig:720p_rendering_performance}
\end{figure}

Il grafico in fig. \ref{fig:720p_rendering_performance} si basa su una simulazione di 5 secondi con tipologia grafo mesh; possiamo notare che al
crescere del numero degli switch il tempo per il rendering del video cresce in modo lineare. Possiamo concludere che il codice in fig. \ref{codice:create_animation}, opera con 
complessità \(O(n)\). Ipotizzando quindi un caso d'uso realistico in cui non viene previsto un grafo completo nell'impiego di una rete di data center
possiamo concludere che la complessità generale del visualizzatore sia il peso della creazione delle strutture, caricamento dal files e creazione base grafica, sommato 
al peso dato dalla parte di animazione ottenendo complessità lineare come riportato nell'equazione \ref{eq:complexity_visualizer}.

\begin{align}
    O(c + n) = O(n)
    \label{eq:complexity_visualizer}
\end{align}



\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/480_720_1080_rend_perf.png}
    \caption{comparazione prestazioni per risoluzioni di 480, 720p e 1080 a 30 fps}
    \label{fig:480_720_1080_rend_perf}
\end{figure}

Volendo osservare i test da un'altra prospettiva, possiamo intendere il tempo di rendering come la variabile dipendente rispetto al numero di switch; in questo
esempio mostriamo una comparazione con le risoluzioni 480p, 720p e 1080p renderizzati a 30 fps(frames per second),
 sempre per 5 secondi di simulazione con grafo mesh, come mostrato in fig. \ref{fig:480_720_1080_rend_perf}. Possiamo osservare dal grafico che l'andamento è lineare per tutti i tipi di rendering analizzati.

\chapter{Conclusioni}
Facendo un riepilogo dei punti cardine dello sviluppo del progetto, si è potuto giungere a diverse conclusioni. Dal punto di vista delle prestazioni implicate
dai formati scelti json e yaml, si è dimostrato che json è incredibilmente più performante rispetto a yaml per quanto riguarda files di grandi dimensioni, possiamo vederne un risultato nel test raffigurato in fig. \ref{fig:json_yaml_wr_comparison}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/json_yaml_wr_comparison.png}
    \caption{comparazione prestazioni json e yaml, scrittura e lettura}
    \label{fig:json_yaml_wr_comparison}
\end{figure}

Il test è basato sulla configurazione avente tempo di generazione 5 secondi e tipologia di grafo mesh con links aventi capacità 1 Gbps.
In questo caso, così come anche i futuri test che verrano riportati, si considera il tempo come la variabile dipendente dal numero di switch impiegati.
Possiamo osservare dal test che json è decisamente più veloce di yaml sia in scrittura che in lettura, tanto da avere tempi praticamente sovrapposti, mentre per yaml,
seppur con un andamento lineare, ha un coefficiente angolare che fa pesare molto di più l'andamento della curva. Quindi possiamo concludere che json è decisamente la scelta più opportuna 
per i fini del progetto. Risulta comunque interessante notare l'andamento di json nella lettura e scrittura per un numero di switch superiore a 7; avendo la stessa configurazione di test precedente otteniamo i grafici in fig. \ref{fig:json_wr_nature} e \ref{fig:json_writing_reading}.

\begin{figure}[h]
    \centering
    \begin{minipage}{0.48\textwidth}
      \includegraphics[width=\linewidth]{immagini/json_wr_nature.png}
      \caption{json, lettura e scrittura da 2 a 10 switch}
      \label{fig:json_wr_nature}
    \end{minipage}\hfill
    \begin{minipage}{0.48\textwidth}
      \includegraphics[width=\linewidth]{immagini/json_writing_reading.png}
      \caption{json, lettura e scrittura da 2 a 10 switch}
      \label{fig:json_writing_reading}
    \end{minipage}
\end{figure}

Osservando i grafici notiamo come il carattere degli andamenti di scrittura e lettura di json prenda forma a partire da una configurazione con 7 switch,
delineando un andamento lineare in entrambi i casi, con un'ottima performance per la lettura. Per quanto riguarda il peso dei files prodotti abbiamo visto yaml produce
files decisamente più piccoli di json, possiamo farci un'idea dai dati registrati in fase di test in fig. \ref{fig:json_yaml_files_dim}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/json_yaml_files_dim.png}
    \caption{comparazione dimensioni files json e yaml}
    \label{fig:json_yaml_files_dim}
\end{figure}

Possiamo concludere che la dimensione dei file json è in media 2.7 volte maggiore rispetto ai corrispondenti file yaml, 
indicando un rapporto di dimensione di circa 2.7 tra i due formati. Ciò è chiaramente un pro nei confronti di yaml, tuttavia la velocità che riesce a garantire json è talmente 
superiore da far propendere per un compromesso in termini di dimensione dei files, rendendo quindi json una scelta preferenziale.
Per quanto riguarda generatore, analizzatore e visualizzatore grafico, possiamo concludere che tutti i moduli del progetto operano in tempo lineare, fatta eccezione della tipologia di grafo completo che intrinsicamente porta dietro di se una natura di complessità quadratica,
rappresentando così un'ottimo risultato in termini prestazionali.
Un'altra conclusione, non banale, riguarda l'essere riusciti a realizzare un prodotto di analisi di rete da una libreria che nasce come scopi relativi a video esplicativi matematici, come possono essere grafi cartesiani animati, spazi vettoriali animati e così via;
si è riusciti quindi a sfruttare la libreria per scopi non strettamente inerenti ai suoi scopi di esistenza, questo processo di adattabilità ha portato a un percorso formativo decisamente creativo, sperimentando nuove soluzioni con in mezzi forniti.
Questo processo fa si che ci siano ampi margini di manovra per applicazioni future, sia legati al concetto di cosa si propone di fare questo progetto sia in termini di integrazioni future di caratteristiche; il concetto che sta alla base del progetto può essere allargato al di fuori di un data center e trovare
altri terreni in cui potersi adattare, sfruttandone le caratteristiche di base si potrebbe adattare l'applicazione ad esempio per il traffico di reti stradali in cui 
i nodi sono rappresentati da punti d'interesse, raggiungibili tramite strade (i link) e con i pacchetti che rappresentano i veicoli, analizzandone il traffico, oppure per reti di gioco multiplayer massivo (MMO), in cui la topologia mesh può essere utilizzata per gestire la comunicazione tra server distribuiti geograficamente, reti di sensori 
in cui la topologia mesh permette ai dispositivi di comunicare anche in condizioni ambientali difficili o in scenari dove i nodi sono distribuiti in modo irregolare, gli ambiti sono potenzialmente tanti.
Un'altra caratteristica di Manim che può essere sfruttata in futuro è la possibilità di renderizzare video in 3D, infatti la libreria supporta anche mobject e spazio vettoriale 3D e potrebbe essere interessante rappresentare ad esempio una rete satellitare che faccia uso di topologie torus e mesh, potendo 
rappresentare la tridimensionalità di un'orbita terrestre, oppure reti di droni, in cui la topologia mesh permette ai nodi di comunicare direttamente l'uno con l'altro senza necessità di un'infrastruttura centrale e potendo sfruttare lo spazio 3D per rappresentare i droni.


\chapter*{Ringraziamenti}
\addcontentsline{toc}{chapter}{Ringraziamenti}
\chaptermark{Ringraziamenti}
\rhead{}
Questo percorso è stato per il sottoscritto una grande opportunità sotto diversi punti di vista; ha rappresentato grande fonte di arricchimento 
professionale e personale, mi ha fornito competenze complementari
agli insegnamenti ricevuti durante il mio percorso di studi soprattutto in ambito front-end, 
ho approfondito la mia comprensione i tutti i campi incontrati, acquisito nuove competenze tecniche e consolidate altre con cui sono entrato in contatto precedentemente.
Personalmente trovo di non poter concludere meglio di così il mio percorso accademico, 
avendo avuto l'opportunità di dedicare gli sforzi, in questa prova finale, verso qualcosa su cui nutrivo forte interesse, ovvero la programmazione di elementi grafici e loro animazioni in modo programmatico.
Ed è in termini di opportunità ricevuta che desidero esprimere la mia sincera gratitudine al mio Relatore, Daniele De Sensi, per avermi accolto,
per essersi prodigato tento per trovare l'ambito di interesse che mi sarebbe piaciuto affrontare, per la sua guida e per il
supporto inestimabile e prezioso, fondamentale per il mio sviluppo professionale durante questo periodo.
\newline
\newline
Desidero ringraziare la mia compagna di vita, Chiara, il mio faro nella notte, senza la quale questo traguardo probabilmente
 non sarebbe stato possibile, per il supporto costante, la pazienza e per aver creduto fortemente in me; e la mia piccola Giulia, Atena, mia figlia,
che ogni giorno mi insegna un pezzo di vita, mi dona gioia e speranza. 
\newline
\newline
Ringrazio la mia famiglia, per l'amore, il supporto costante e la pazienza che hanno avuto nel mio lungo e tortuoso percorso.
\newline
\newline
Un doveroso ringraziamento va a Lucio Molo e Mauro Semproni, miei colleghi universitari e cari amici, che hanno condiviso con me parte della mia vita
accademica e mi hanno aiutato a viverla nel modo più sereno e pieno possibile.
\newline
\newline
Desidero infine ringraziare gli amici che mi hanno accompagnato durante il percorso, per l'immensa
compagnia e per avermi fatto sentire bene anche nei momenti più duri.



\printbibliography

\backmatter
\cleardoublepage
\phantomsection % Give this command only if hyperref is loaded
\addcontentsline{toc}{chapter}{\bibname}
% Here put the code for the bibliography. You can use BibTeX or
% the BibLaTeX package or the simple environment thebibliography.
\end{document}